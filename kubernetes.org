* https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/ 
** Traditional deployment: Running apps on physical servers. If multiple apps run on the same server, one app might hog up all the resources. An upgrade meant another physical server. Maintaining multiple physical servers were expensive.
** Virtualized deployment: Run multiple VMs on a single CPU. Basically another abstraction between the environment and the app. Also isolates apps (no app an share resources). This is also security between apps. Better utilization of resources. Apps are added and updated easily, as the physical resources are represented as a cluster of disposable virtual machines
** Container deployment: Similar to VM, but relaxes isolation. Can be thought of as lighweight VMs, with extra benefits:
*** Agile app creation and deployment (more efficient than VM)
*** more reliable for a CI/CD due to a image immutability
*** More observability
*** Environmental consistency. Runs exactly the same on laptop and cloud
*** Portability: on Ubuntu, RHEL..., Google Kubernetes Engine
*** App-centric management: an abstraction of another level! From running an OS on virtual hardware. To run app on an OS usling logical resources
*** More loosely coupled..: apps broken into smaller independent pieces, can be deployed dynamically. Not a monolithic stack running on a single-purpose machine
*** Resource isolation: predictable app performance
*** Better resource utilization
** Kubernetes can handle containers for you, and takes care of scaling and failover for you. It provides:
*** Service discovery and load balancing
*** Storage orchestration
*** Automated rollbacks and rollouts (You achieve this by describing your desired state)
*** Automatic bin packing: Provide Kubernetes with cluster of nodes, determine CPU and RAM each container needs, Kubernetes will fit container to nodes.
*** Self-healing
*** Secret and config management
** Kubernetes is not a traditional PaaS system, but provides many features. However most of these features are optional. It:
**** Does not limit the types of application supported
**** Does not deploy source code and does not build your app
**** Does not provide app-level services: middleware, Database, etc...
**** Does not dictate logging, monitoring, or alerting solutions
**** Does not provide or mandate a configuration language/system (Jsonnet)
**** Does not provide comprehensive machine configuration, maintenance, management or self-healing system
**** Additionally, it is not a mere orchestration system. It eliminates orchestration. Orchestration is execution of a defined workflow. A -> B -> C. It comprises independent composable control processes (??)  
* https://dzone.com/articles/learn-how-to-setup-a-cicd-pipeline-from-scratch 
** (this TOPIC is slightly unrelated, as it pertains to SDLC) 
** the backbone of modern DevOps environment
** bridges the gap between development and operations team
** continuous development, contin.. testing, c.. integration, c.. deployment, and c.. monitoring
** CI = Continuous Integration. CD = Continuous Delivery/Continuous Deployment
** During the build phase (in the case of Java), which is after the version control phase. You get all the features from various branches, merge them, finally compile them (compiler). 
** then the Testing phase. Such as Unit Testing.
** Then comes the deploy phase. Deploy to a staging/testing server, where you can view your app
** Then another sanity test. Auto Test phase. If everything is accepted.. then....
** deploy into production. Deploy to Production phase.
** If there is any error in every step, you can shoot an email bak into the Dev team. They will push code back into version control, and everything goes through the pipeline.
* https://thinkpalm.com/blogs/docker-demystified/
** Same points as before.
** because of points mentioned, containers are faster
** Virtual memory is provided for isolation
** "A hardware VM system forces certain communiation with a VM to go through the hardware". 
***  VMs are managed by a hypervisor and use the VM hardware 
***  the container systems provide the operating system services from the underlying host, while isolating the applications that use virtual-memory hardware
** VMs provide an abstract machine that makes use of the device drivers targeting it, while a container provides an abstract operating system
** Typically a VM hosts multiple applications that might change over time while a container normally has a single application (Sometimes a fixed set of containers in single container)
** Docker:
*** With Docker, you can manage infrastructure like you manage our application
*** Containers are usually lightweight because they do not need the extra load that a hypervisor has
*** Container is also a unit for distributing your code
*** The docker daemon is managed through scripts or CLI commands generated by the REST API.
* https://containerjournal.com/features/biggest-challenges-facing-docker/
** Limited Windows support  (its getting there)
** Much limited for Mac
** Docker ecosystem is now very large and fragmented. Clear rift between:
*** vendors favoring Swarm (aligned with Docker Inc)
*** Kubernetes (championed by Red Hat, Google and CoreOS)
*** There is now some dangerous comptability between the 2!
* https://docker-curriculum.com/
* https://www.guru99.com/docker-tutorial.html
* https://www.tutorialspoint.com/docker/index.htm
* https://www.linux.com/tutorials/set-cicd-pipeline-kubernetes-part-1-overview/
