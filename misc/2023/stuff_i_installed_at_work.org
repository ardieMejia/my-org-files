
#+OPTIONS: toc:nil

* Personal stuff I installed
** smallworld software strange that   its closed source
** Emacs 23, so boring coz its so old
** VirtualBox, Lubuntu.etc...
** PowerToys for keyboard shortcuts
** Git
* (Official) Stuff I did so far.
** Install Java
** we downloaded 3 files
** Emacs, emacs.rar (??), EO installer
** Moved it to E drive
** moved Emacs and extract at same level as SmallWorld
** run configure.exe as admin
** We also added some config to gis_aliases under core/config

#+begin_quote

emacs:
EMACSROOT    = E:\SmallWorld\emacs-28.2
title    = GNU Emacs 28.2
program    = %EMACSROOT%\bin\runemacs.exe
icon_file    = %SW_WHICH_GIS_ALIAS_PARENT_DIR%\bin\runemacs.exe
log_file    = nul:
product    = emacs
EMACSLOADPATH    = %EMACSROOT%\share\emacs\28.2\lisp; %EMACSROOT%\share\emacs\site-lisp
PATH    = %PATH%;%EMACSROOT%\bin
HOME    = %HOMEDRIVE%%HOMEPATH%

#+end_quote

** copy license -> message.ds under smallworld_registry
** Change file properties of EO_Demo (target, arguments like -a)

E:\SmallWorld\core\bin\x86\gis.exe -a "E:\SmallWorld\electric_office\config\gis_aliases" -e "E:\SmallWorld\core\config\environment.bat" emacs


** Run config program under core
** Had to add Everyone as new group at parent directory (SmallWorld), before anything happened. (Make sure permissions all set/allowed) Finally clicking "Show Licenses" finally worked 
** Start server if itsnt started
** also, under datastore server admin -> security -> add "rights all" at top -> commit
** also licenses -> show licenses -> (should show details)
* Learning progress (user)
** [%HOME%] runalias eo_open -login root
** We learned how to create a map, resize that map area & add a legend
** We learned how to update the state of the map (so it shows in green instead of red)
** There projections we can change, but we always us WGS projection, standard
** we learnt using the app manager (I dont remember what we did with the administration suite)
** "How to get help" will open the official help website
** ==================================================
** we learnt about object types, chains (line), points (raster?), area (polygon). Please fix this one.
** we can refresh the whole database, or the whole map
** Geometry
*** joint,valve,roundabout = point
*** cable,pipeline,road = line
*** substation,duct,park = area
*** name,length = annotation
*** background map, scanned image, surface model = raster
** File -> new project and design 
*** after creating details, always remember to say "no" to checking for overlap
** File -> Browser design -> "Design Browser"
*** we clear filter & and "run query"n to list all designs
** File -> New Checkpoint
*** When we go to app manager, and open suite admin, we can see our named version
*** I dont understand this part at all
** File -> State Model Viewer -> "shows the possible state paths"
** ==================================================
** We about design
*** DM_top is the upmost layer/object
*** When we first open we are presented with DM_top
*** We then create a new design
** We learnt the object editor
*** We learnt insert, update and delete a trail geometry
*** By adding a new trail, we can lock, highlight, and move-to. To navigate back to that point after some journey
*** There are mandatory fields
*** We forgot we can actually clear trail by right-clicking
** Object editor, we filed mandatory fields after creating trail (area), must fill extent, tick mark. Remark to update
** version management
*** We create a new checkpoint from the window
*** It has numbering naming system in the database, not our chosen name
***** Good names like, "before_delete", "before_update"
***** New alternative creates child checkpoints
***** Rollback and commit. rollback = undo to last changes. commit = save
** ==================================================
** dataset schema -> Collection (table) (Eg cable) -> Field (Records)
** UG OH MV HV lV
** visibility, selectibility, hitability
** copying properties for insertion?
*** select existing cable, create trail, select "geometry from trail", click "insert"
** Everytime, create new design, theres PLAN_*** in versiona management
* Wishlist:
** https://stackoverflow.com/questions/42566799/how-to-bring-focus-to-window-by-process-name
*** Basically write a Powershell script that switches focus to another app. Better idea is down below, to use Window name, instead of process name
* Rearrange:
** We need to rewrite inside GIMP.org or photoshop.org or ImageMagick.org or something
*** https://www.gimpusers.com/forums/gimp-user/3403-writing-values-to-a-file-from-within-gimp
** We need to recheck the code and write this somewhere in Emacs.org or something. But not sure if its eLisp or commonLisp
*** https://stackoverflow.com/questions/9495376/how-to-create-and-write-into-text-file-in-lisp
* Day1:
** gis_aliases under electric_office/config/gis_aliases, we can set 
** running core/config will start server
*** it is a 2 way communication
*** swmfs (data store server ) sits between DB and app (it is a 2 way communication)
*** supports real life update from mobile
*** from web, they will publish wms link
**** They cal it WMS 
**** https://enterprise.arcgis.com/en/server/latest/publish-services/linux/wms-services.htm
*** 
** managing SOC
*** run manage_soc()
*** under electric_dm, we open GIS, -> right click properties -> we click GIS -> ds -> files -> 1
*** 
** Based on the business process, when we create plans, it either creates for all 3 datasets (GIS, electric, etc..)
** 
*** Digitization
*** QAC
**** We have several routines
*** approval
**** 
*** ready for posting
*** posted - once posted to DM_TOP, we have a scheduler that syncs with WORKING_TOP
** Smallworld Framework Arch
*** We have classes for example for each actions, plugins, GUI framework & PLugin Framework
*** We need to add the changes to XML, before we see the changes?
** When creating GUI elements, like an option under a menu bar, 2 places need it defined:
*** E:\SmallWorld\electric_office\modules\application_modules\sweo_base_user_application\resources\base\data
*** Under this folder, config.xml registers the plugin, GUI.xml registers the menu bar
** Example commands:
*** print(smallworld_product.applications)
this will display
sweo_dm_admin_application(sweo_dm_admin_application) 
sweo_base_user_application(sweo_dm_user) 
*** command basically shows all applications under product
*** class browser get be opened using F3-F3
*** IN searches specific class (make sure its <loc>)
**** methods
**** classes
**** pragma flags
**** inheritance options
**** override options
*** Tab switch between searching for classes or methods
*** "/" clears the string
*** F3-<down> expands methods
*** F3-<up> contracts methods
* Day 2:
** you create a class using def_slotted_exemplar
print_heirarchy
print_ancestry

debug_print()

** Read and understand!!
*** class name
*** inheritance
*** local methods
*** inheritance methods
*** slots
*** what do object slot points to??
*** how to objects related to each other??
** More commands to check
write()
print()
show()
** key  (in key-value pair) and symbol are the same thing
** you can have 2 of the same symbols in a collectionq
** You can also enquire class_name on any variable, coz variable are objects!!
var1 << 234
var1.class_name
propert_list.new_with(:hello, "123", :hello, "567")
** apropos needs a bracket and ""
var1.apropos("")
** _block and _endblock is basically lambda (anonymous function) in lisp
** Like this
_block
		_local a << "123"
		_local b << "456"
	_endblock
** an actual function

test << _proc()
       	       _global haha
	       haha << 345
		_local a << "rty"
		_local b << "tyu"
	_endproc
** Dynamic variables
test2 << _proc()
       	     	_dynamic !var1! << "spiderman"
		write(!var1!)
_endproc

==========

test3 << _proc()
       	     	_dynamic !var1! << "nothing"
		test2()
		write(!var1!)

========== for unset variables

_if var2 _is _unset
       _then
		var2 << 345
	_endif
** loops
*** for loops
sv << {1,2,3,4,5,6}
_for i _over sv.fast_elements()
       _loop
		write(i)
	_endloop
*** for loops with range()
*** loop can have a name!!
*** In one example, a function (procedure) can have a different naming, but checking with class_name produces "global variable". So it may refer to return value
*** only hash tables behave like this, occupying the same memory address

ht << hash_table.new()
ht2 << ht
*** magik doesnt need format directive like lisp (%s)
** _pragma is to define class accessibility (restricted, basic, etc...)
** def_slotted_exemplar is to define a class
** remex is to remove class definitions before we recreate and recompile
** Ehan
*** representation in .shp files
**** polygon/area
**** line/chain
**** point
**** text/label/annotation
*** vhs
**** Related to display scale (some objects hidden or showed). Visibility, HIttability, Selectability
**** From admin -> ACE configuration -> object configuration
** Common beginner mistakes
*** Forgetting () after fast_elements
*** when create method for class (_pragma n then _method), putting  brackets dont matter, but 
*** putting () brackets after certain properties like size 
*** misunderstanding that cable_segment is actually a table (collection)
*** when getting collections from databases, putting [] brackets and () in the wrong places (need to know which is a method and which is not)
**** Like this
#+begin_src magik
  gis_program_manager.databases[:electric].collections[:eo_cable_segment_inst].field(:source_data)
#+end_src
**** Notice the collections[] is the table, whereas field is a function
*** When searching through plugins. the real name inside (). like this
a dm_construction_pack_plugin(construction_pack)
**** construction_pack is the real name
*** When apopos-ing we can come up with "slot" methods, we still use them like methods aka
plugin2.current_trail.geometry[1][1].x
**** geometry is named "slot" under apropos() but we use (.) like a method
* Day 3:
** using ! marks
#+begin_src magik

  gis_program_manager.databases[:electric]
  var1 << ! # ---------- gets the output value one line before which is value outputgis_program_manager.databases[:electric]
  var2 << !! # ========== gets the output value 2 lines before outputgis_program_manager.databases[:electric]

#+end_src

** getting database information
#+begin_src magik

  gis_program_manager.databases[:electric].table_for_external_name("Cable Segment")
  # you can also put size at the end
  gis_program_manager.databases[:electric].table_for_external_name("Cable Segment").size
  # you can also print the first record
  print(gis_program_manager.databases[:electric].table_for_external_name("Cable Segment").an_element())



  
#+end_src

** getting collection information
#+begin_src magik
  
  # you can even put the internal name of the collection
  print(gis_program_manager.databases[:electric].collections[:eo_cable_segment_inst].an_element())

  # getting available methods under colection
  # You forgot the name. You can "apropos" the methods available
  gis_program_manager.databases[:electric].collections[:eo_cable_segment_inst].apropos("nth")
  # then you get a certain nth record
  print(gis_program_manager.databases[:electric].collections[:eo_cable_segment_inst].nth_record(100))

  # Can use internal and external name
  print(gis_program_manager.databases[:electric].collections[:eo_cable_segment_inst].field_for_external_name("Source Data"))
  print(gis_program_manager.databases[:electric].collections[:eo_cable_segment_inst].field(:source_data))

#+end_src





** We need to learn plugins
*** Rearrange all this
app << smallworld_product.application(:sweo_dm_user)
app.apropos("plugins")
_for i _over app.plugins() # ===== why cant we apropos here?
       _loop
       write(i)
       _endloop

       somePlugin << app.plugin(:maps)

       somePlugin.current_map

==========
       
       print(somePLugin.current_map.current_selection)

       ==========

       print(somePLugin.current_map.current_selection.an_element())

       ==========

       print(somePLugin.current_map.current_selection.an_element().rwo)

       # ========== rwo -> real-world-object
       
** Reading errors
#+begin_quote

Error: Object unset does not understand message close()
# ===== variable doesnt exist

#+end_quote

* How do we delete an item from a collection/list/array/vector?
* Can we do markers? Like read a file and pass the same pointer/marker to another function to continue reading somewhere else 

* Day 4:
** Note the command below
gis_program_manager.databases[:electric].table_for_external_name("Service Point").nth_record(99).usage
** Common beginner mistakes:
*** the field in the GUI is basically the field like a database or a field. So we dont need [:usage] or ("usage"). We just dot (.) like a method. 
*** Basically, like our CSV files on fiverr?

#+begin_src magik
  gis_program_manager.databases[:electric].table_for_external_name("Service Point").nth_record(99).connection_type
  # Again very unusual, connection_type has underscore automatically. But doesnt show in GUI

  gis_program_manager.databases[:electric].table_for_external_name("Service Point").apropos("field")
  # you will get .field()

  # try to search through this iter as a learning experience
  print(gis_program_manager.databases[:electric].table_for_external_name("Service Point").field(:connection_type).type.enumerator.sorted_values)
#+end_src

** A for loop that quits half way. Im sure there are many ways
       _block
       my_i << 1
       _for item _over my_iter4.fast_elements()
       _loop
		write(item)
		_if my_i _is 3
		_then
			_leave
		_endif
		my_i +<< 1
       _endloop
       _endblock
** A simpler one
_block
       _for i _over range(1,3)
       _loop
		write(my_iter4[i])
       _endloop
       _endblock
** 
* Day 5:
** Common beginner mistakes
*** adding _pragma at console. _pragma is only needed in files.
*** Forgetting to remex classes -> remex(:SoMeClAsS)
** Creating classes of cars and makes and models
*** car.magik, ford.magik, honda.magik, accord.magik, prelude.magik, ranger.magik, focus.magik
#+begin_quote

========================= car.magik =========================
_package sw


_pragma(classify_level=basic,topic={test},uage={test})
def_slotted_exemplar(:car,
	{{:price,_unset}},:plugin
)
$

_pragma(classify_level=restricted,topic={help})
_iter _method car.makes()
	##
	## car make method
	##

	_for a_val _over {honda.new(), ford.new()}.fast_elements()
	_loop
		_loopbody(a_val)
	_endloop
_endmethod
$
==================================================


========================= ford.magik =========================
_package sw


_pragma(classify_level=basic,topic={test},uage={test})
def_slotted_exemplar(:ford,
	{{:price,_unset}},:plugin
)
$(delete-region (point) (point-max))

_pragma(classify_level=restricted,topic={help})
_method ford.name
	_return "ford"
_endmethod
$


_pragma(classify_level=restricted,topic={help})
_iter _method ford.models()
	##
	## ford models method, not the s, whatever
	##
	_for a_val _over {focus.new(), ranger.new()}.fast_elements()
	_loop
		_loopbody(a_val)
	_endloop
_endmethod
$
==================================================


========================= ranger.magik =========================
_package sw

_pragma(classify_level=basic,topic={test},uage={test})
def_slotted_exemplar(:ranger,
	{{:price,_unset}},:plugin
)
$


_pragma(classify_level=restricted,topic={help})
_method ranger.name
	_return "ranger"
_endmethod
$
==================================================

#+end_quote





** Read this method
_method map_view.zoom_by(a_factor)
	## Zooms the map view by A_FACTOR.
	   _if .current_view_parameters _isnt _unset
	   _then
	   new_view_def << .current_view_parameters.copy()
	   new_view_def.scale *<< a_factor
	   _self.set_view( new_view_def )
	   _endif
_endmethod


========================= console =========================
myclassreader << _proc @myclassreader(a_folder_path)
       v_classes << {"accord.magik","prelude.magik","focus.magik","ranger.magik","honda.magik","ford.magik","car.magik"}
       _for a_file_name _over v_classes.fast_elements()
       _loop
       	    load_file(a_folder_path + "\" + a_file_name)	
	_endloop
	write("==================================================")
	
	_for each_make _over car.makes()
	_loop
		make << each_make.name
		write("make: ", make)
		_for each_model _over make.models()
		_loop
			model << each_model.name
			write("model: ", model)
		_endloop
	_endloop
_endproc
	
	
	
myclassreader("c:/Users/ahmadardie.r/Documents/my-trash/day5_practice")
==================================================


** Homework:
*** trail geom -> convert to pseudo_area -> .overlap? (service point location)
*** aNSWER
myServicepoint << myMap.current_map.current_selection.an_element().rwo.LOCATION
WILL GET ACTUAL GEOMETRY
note: myMap is from plugin, get the plugin
trail_s_geom << myMap.current_map.trail.as_pseudo_geometry
WILL GET ACTUAL TRAIL AS PSEUDO GEOMETRY
* Day 6
** Errors from the command
*** We can learn to trace the errors (Refer to slide note)
#+begin_src magik
  **** Error: Object unset does not understand message manager
       does_not_understand(object=unset, selector=:manager, arguments=simple_vector:[1-0], iterator?=False, private?=False)

  ---- traceback: Alchemy-REPL (light_thread 1420152204) ----
  time=12/07/2023 10:01:00
  sw!version=5.2.7.0 (swaf)
  os_text_encoding=cp1252
  !snapshot_traceback?!=unset

  condition.raise()            (sys_src/guts/condition.magik:616)
  object.does_not_understand()            (sys_src/guts/object.magik:810)
  object.sys!does_not_understand()            (sys_src/guts/object.magik:684)
  map_view.map_manager            (modules/sw_swaf/map_plugin/source/map_view.magik:2227)
  map_view.calculate_view_for_goto_bounds()            (modules/sw_swaf/map_plugin/source/map_view.magik:2466)
  map_view.goto_bounds()            (modules/sw_swaf/map_plugin/source/map_view.magik:1006)
  map_view.goto()            (modules/sw_swaf/map_plugin/source/map_view.magik:1438)
  <unknown exemplar>.<unknown method>            (Evaluated-inline:1)
  magik_rep.process_command()            (sys_src/misc/magik_rep.magik:136)
  magik_rep.cli()            (sys_src/misc/magik_rep.magik:90)
  system.session_start()            (sys_src/guts/system.magik:3185)
  
#+end_src
**** Basically our map_view.goto() produces the error. But we can trace the error being produced at map_view.map_manager
** Just 2 simple method to compare 2 outputs of different methods from different classes
#+begin_src magik

    # ==================== n1.magik =========================
  remex(:n1)
  $

  _package sw
  $

  _pragma(classify_level=basic, topic={test}, usage={test})
  def_slotted_exemplar(:n1,
	  ## 
	  ## 
	  ## 
	  {},:plugin)
  $

  _pragma(classify_level=basic, topic={test}, usage={test})
  _method n1.out_cost
	  _return "cbvg asdqwd qwd qwd qaq"
  _endmethod
  $

  # ==================================================

  # ==================== n2.magik =========================
  remex(:n2)
  $

  _package sw
  $

  _pragma(classify_level=basic, topic={test}, usage={test})
  def_slotted_exemplar(:n2,
	  ## 
	  ## 
	  ## 
	  {},:plugin)
  $

  _pragma(classify_level=basic, topic={test}, usage={test})
  _method n2.out_cost
	  _return "zsdasd qweqwe "
  _endmethod
  $

  # ==================================================
  # ========================= console =========================
  trace_out_proc << _proc(n1, n2)
			   ## 
			   ## Procedure for sorting the .new_nodes
			   ## priority_queue. 
			   ##
			   # Orders simply on .out_cost.
			   >> n1.out_cost _cf n2.out_cost
  _endproc

  trace_out_proc(n1,n2)
  # ==================================================

#+end_src

** :plugin is needed for cloning an object


#+begin_src magik


  # ========== at console
  def_slotted_exemplar(:person,
		      {{:address, "mentari"},
		       {:number, 01023234}
		      })

  var1 << person.new() # ========== this will produce error

  # we need :plugin to be able to clone this class (what other languages by default simply call it creating an object)


  def_slotted_exemplar(:person,
	  {{:address, "mentari"},
	   {:number, 01023234}
	  },:plugin)


#+end_src

** 

* Day 7
** shared constants and shared variables
#+begin_src magik

  n1.define_shared_constant(
	  :month_names,
	  {"January", "February", "March"},:private
	
    )
  $

  n1.define_shared_variable(:ref_count,0,:public)
  $  

#+end_src

** we access both of these as a method/property (the overpowering . notation). (This is still not naturally for me)
#+begin_src magik
  created_obj.month_names
  created_obj.ref_count
#+end_src

** When we create our own .new method
#+begin_src magik

  _method n1.new()
	  _self.ref_count +<< 1
	  _return _clone
  _endmethod
  $
  # ===== that avoids the problem of having to deal with this error
  # ===== **** Error: Object a n1(unset) sent message init() with too few arguments (requires 2, given 0)
  # so that we can create an object just like this
  new_object << n1.new()


  # If we want arguments
  _method n1.new(_gather args)
	  _self.ref_count +<< 1
	  >> _clone.init(_scatter args)
  _endmethod
  $

#+end_src

** Inheritance: The shape class
*** this is also easier than in other languages, its defined as the last element in the parent bracket, so its out of the way
** Personal Note:
*** I must be suspicious of _self. always. Coz it always confuses me. I must think of the variable name first. The put _self. where needed. 
** An example of creating a shape class, a rectangular class, and then define a mixin. But we have to remex before inheriting that inside our rectangular class. 
#+begin_src magik

  def_slotted_exemplar(:shape,{{:x,_unset,:writable},{:y,_unset,:writable},{:color,_unset,:writable}})
  def_slotted_exemplar(:rectangular,{{:x,_unset,:writable},{:y,_unset,:writable},{:color,_unset,:writable}},:shape)

  # ===== we can redefine freely the slots, since its writable,
  shape.x << 123

  _method my_special_mixin.whatami
	  write("hello there", _self.x)
	  write("Im a ", _self.class_name)
  _endmethod

  remex(:rectangular) ===== need to remex() first
  def_slotted_exemplar(:rectangular,{{:x,_unset,:writable},{:y,_unset,:writable},{:color,_unset,:writable}},{:shape,:my_special_mixin})

	  ========================= we can actually redefine our method inside our class, but we cant redefine our class without remex()

  _method my_special_mixin.whatami
	  write("hello there", shape.x)
	  write("Welcome everyone its me the ", _self.class_name)
  _endmethod

#+end_src


** Reminder:	
*** What if we got something like this

simple_vector(1,4):
1 	1 
2 	simple_vector:[1-4] 
3 	3 
4 	4

===== We can use this

_for key,value _over var1.fast_keys_and_elements()
       _loop
		
		_if value.class_name _is :simple_vector
		_then
			_for item _over value.fast_elements()
			_loop
				write("level 2 : ", item)
			_endloop
			_continue
		_endif
		write(value)
	_endloop

========================= output =========================
1
level 2 : spiderman
level 2 : is
level 2 : a
level 2 : pussy
3
4

** Hey we did it!! a procedure adding an element from 2 ropes into a multi-rope. No errors so far. Inspired my Common lisps datatype list. Where they can pop elements.
#+begin_src magik

  feedMe << _proc @feedMe(rope1, rope2)
		    # compare the sizes first
		    # whichevers bigger make it the size of final rope
		    _if rope1.size < rope2.size
		    _then
			    m_size << rope2.size
		    _else
			    m_size << rope2.size
		    _endif

		    # a rope of ropes
		    full_rope << rope.new_for(2)
		    full_rope[1] << rope.new_with()
		    full_rope[2] << rope.new_with()

		    _for mycount _over range(1,m_size)
		    _loop @outer
			    _if rope1.empty? _orif rope2.empty?
			    _then
				    _leave @outer
			    _else
				    full_rope[1].add(rope1[1])
				    full_rope[2].add(rope1[1])
				    rope1.remove_nth(1)
				    rope2.remove_nth(1)
				    write("were removing rope1 at ", mycount)
			    _endif
		    _endloop		 		  
	 _endproc

  # ==================================================
  var1 << rope.new_with(1,2,3); var2 << rope.new_with(4,5,6,7)
  # ==================================================
  feedme(var1,var2) ===== IT WORKS!!

#+end_src

* Day 8
** datatypes with keys and values
*** rope, hash table, equality property list, property list
*** hash table uses symbols as keys, equality property list uses strings, property list uses symbols
*** equality set, also a dataytype, will not include duplicates
*** equality bag, VERY interesting, does not have duplicates, but stores occurences of duplicates upon creation
*** sorted collection has sorting. but rope HAS a sorted method
*** sorting with our own method
#+begin_src magik
  
  rope1 << =========================

  dec << _proc(a,b)
		 >> b _cf a
	 _endproc

  print(rope1.as_sorted_collection(dec))

#+end_src


** Personal
*** Lets create a "get" method that returns when list matches a pattern
*** This is probably a useless exercise since even fields are objects. And strings are important datatype in magik. So we need a different workout
*** 
** Random note:
*** When implemented, whats the difference between a field and a slot ??     (:someSlot)
*** If you try init() <--------> new() exercise. You'll quicky realize . notation even more ambiguous (whats the different between shared variables and a slot??)
*** Here's some interesting discovery. Also the init() <--------> new() exercise. passing arguments from .new() to .init() is just a convention. You can also pass .new2 to .init(). The result is the same. 
*** [[file:~/Documents/my-trash/magik_practice/2023-07-14_at_15hours/pop_numbers_at_2.magik][example of .new2 instead of .new we may decide to just delete and copy code here]]
*** ==========
* Day 9 
** hash_table automatically remove duplicates when created (new_with)
** property_list on the other hand allows duplicates
#+begin_src magik
  my_hash << hash_table.new_with({:abc, "abc", :def, "def", :abc, "another one"})
  # the 2nd abc will not be shown
#+end_src
** integers and symbols are same objects (Eg: 1 and 1, :abc and :abc). Strings and float are different objects (Eg: 1.3 _is 1.3 and "asd" _is "asd" will return false)
** set views integers and symbols as "object strict". So objects are not duplicated. Example:
#+begin_src magik

  set1 << set.new_with(1,2,3,123,1,2,3,:asd,:asd)
  print(set1)
  # ========== output ==========
  # 1
  # 2
  # 3
  # 123
  # :asd

#+end_src

** set treats everything like real objects. So, it makes it will have methods like .union(), .intersection(), .difference()
#+begin_src magik

  set1 << set.new_with(1,2,3,4,5,6)
  sw:set(6) 
  Magik> set2 << set.new_with(5,6,7,8)
  sw:set(4) 
  Magik> print(set1.difference(set2))
  # ========== output ==========
  # set:
  # 1 
  # 2 
  # 3 
  # 4 
  # ----- The way to think of the .difference() method, is that it operates ON the first set


#+end_src

** An rwo set example
#+begin_src magik

  _block
	  _local r_set << rwo_set.new()
	  _local sp1 << gis_program_manager.databases[:electric].collections[:eo_service_point]
	  _for a_rwo _over sp1.fast_elements()
	  _loop
		  r_set.add(a_rwo)
	  _endloop
	  write("the size", r_set.size)
	  print(r_set)
	  r_set.add("asd") # only this line will produce error
  _endblock

#+end_src

** Geometry set

#+begin_src magik

  _block
	  _local g_set << geometry_set.new()
	  _local sp1 << gis_program_manager.databases[:electric].collections[:eo_service_point]
	  _for a_rwo _over sp1.fast_elements()
	  _loop
		  g_set.add(a_rwo.location)
	  _endloop
	  write("the size", g_set.size)
	  print(g_set)

  _endblock

#+end_src





==================================================
We must try the conditions. theres also different types like not just :error, but also :warning & :information. TRY IT
==================================================

file_logger << _proc @file_logger(input_file_name, output_file_name)

                    in_stream << external_text_input_stream.new(input_file_name)
		    log_stream << external_text_output_stream.new(output_file_name)

		    

                    _protect
                        _loop@outer
                            a_line << in_stream.get_line()

                            _if a_line _is _unset _then  _leave _endif

                            log_stream.write(a_line)
			    log_stream.write(%newline)
			    

                        _endloop
                    _protection
                        in_stream.close()
			log_stream.close()
                    _endprotect

                _endproc

file_logger("some_path_to_input_file","some_path_to_output_file")



		
* Day 10
** binary formats
** No interesting examples shown. But we rarely use anyway.

#+begin_src magik

  # ========== we can try this with a raw PDF, it will work
  _proc@test (input_file_name, output_file_name)
	  in_stream = external_binary_input_stream(input_file_name)
	  log_stream = external_binary_input_stream(output_file_name)
	  _protect
		  file1 << file_status.new(input_file_name)
		  bv << byte_vector.new(file1.size)
		  in_stream.get_vector(bv)
		  log_stream.put_vector(bv)

	  _protection
		  write("closing files")
		  in_stream.close()
		  log_stream.close()
	  _endprotect
  _endproc

#+end_src
** witness _protect, _protection & _endprotect in action

my_catch << _proc@ my_catch(fname)
       _catch :file_error
       	      _handling error _with
	      _proc(cond)
			_throw :file_error
		_endproc
		a_file << external_text_output_stream.new(fname)
	_endcatch
	write("your bloody file is ", a_file)	
	_if a_file _is _unset
	_then
		condition.raise(:user_error, :string, "unable to wreite to this file" + fname)

					     _endif
_endproc
** It works even in simple situations
_block
		_protect
			"some text".stupid_nonexistent_function()
		_protection
			write("==================================================")
			write("the function stupid_nonexistent_function doesnt exist")
		_endprotect
_endblock
** But commonly used like the following (note the additional use of a flag, which means we combine it with another conditional to make it safe to commit some changes aka file/database/etc changes)
#+begin_src magik

  # Setup a flag
  ok? << _false
  _protect
	  <write some data to the database>
		  # We made it through the ify code. Set flag to true.
		  ok? << _true
  _protection
	  _if ok?
	  _then
		  <commit the database>
	  _else
		  <rollback the database>
	  _endif
  _endprotect

#+end_src
*** Also note that we can use question marks in variables in Magik. Like --> whateverVariable? 
** 
** PLease rearrage this better

#+begin_src magik

  condition.define_condition(:my_error_condition, :error, {:age,:address}, "hello I am #1 years old, and I live in #2")

  # note the usage: using numbers like #1 makes it different from your average function. Error catching functions are special after all. Makes a one-liner easier too

  # to test whether a condition you can use this
  # condition.condition_exists?(:warning)

  condition.raise(:my_error_condition,:age,32,:address,"mentari")

  ========== from method definition: ==========
  method define_condition(name,parent_name,data_name_list, optional reporter,message_accessor) 

#+end_src


* Day 11
** product.def
** Compiling messages

#+begin_src magik
  
  sw_module_manager.apropos("compile_mess")

  # would have to delete msgc to see this in action

  sw_module_manager.compile_messages(:eo_phase_conventions)

#+end_src
** try and catch errors are meant to redirect error flows from its usual flow
** try and catch error

#+begin_src magik

  _try _with cond
  write("Hello")
  write("HELLOOOOOO")
  "asd".enter
  write("nothinnnnnnnngg")
  _when error
	  write(cond.report_contents_string)
  _endtry


  # Like other programming languages, theres an implied variable, that will automatically catch the error. IN the example, its "cond"
  # The variable "cond" is also local

#+end_src
** another catch and try

greet1 << _proc()
       	      _catch @my_tag
       	      write("Hello")
	      greet2()
	      write("Hello again")
	      _endcatch
	      _endproc


	      greet2 << _proc()
       	      write("How are you")
	      "somenonexistent".enter
	      _throw @my_tag
	      _endproc
** Some advanced example (with _proc inside another _proc, and _throw, and _catch, and ). The real question is, why would we want to use this one?
#+begin_src magik

  proc_handle << _proc @proc_handle()
			 _catch :carry_on
				_handling file_does_not_exist _with 
				_proc(cnd)
					write("Catched and processing the error..")
					#cnd.report_on(!output!)
					#!traceback!(!output!)
					_throw :carry_on
				_endproc

				_protect
					condition.raise(:file_does_not_exist,:filename, "abc")
				_protection
					write("<<Error handled..>>") 
				_endprotect
			 _endcatch 
	      _endproc


#+end_src


* Day 12
** =====

#+begin_src magik

  _try
	  _with cond
	  # ===== you can also put _with on a new line
	  condition.raise(:warning,:var1,"some text")

  _when error
	  write("im handling other errors")
	  write(cond.report_contents_string)
  _when warning
	  write("default variables used")
	  write(cond.report_contents_string)
  _endtry



#+end_src
** Food for thought -> 
** Perhaps, perhaps another advantage separating init() from new(), is that we have more flexibility, so we can have a "data filller" function that ends with "data loaded but we skipped the 2nd variable". Example:


#+begin_src magik
  
  def_slotted_exemplar(:my_class,
		      ## 
		      ## 
		      ## 
		      {{:one, 1},{:two, 2}})


  _method my_class.new(var1,var2,var3)
	  >> _clone.init(var1,var2,var3)
  _endmethod


  _private _method my_class.init(var1,var2,var3)
	  .one << var1
	  .two << var3
	  write("data loaded, but we are skipping var2")
	  _return _self
	  # _return _self -----> is only for classes that load :plugins
  _endmethod


#+end_src

** Write about chevron methods. That overload << thingy

*** Say we have a class called i_am_cool

_pragma(classify_level=basic, topic={i_am_cool}, usage={test})
_method i_am_cool.new_value << chev_value
	## 
	## 
	.one << chev_value
	.two << chev_value
	.three << chev_value
_endmethod
$

test << index_and_chevron.new("Marry", "Louis","Rockey")
Global test does not exist: create it? (Y) 

test[:one]
"Marry" 

test.new_value << "Aravindh"
"Aravindh" 

test[:one]


** iter methods remind me of  mapcar in Common Lisp. Its one way to think of it. Basically, "map each of these values to our function here" or "do this n times on our function here"


def_slotted_exemplar(:test_iter, {})


 _iter _method 
test_iter.iter_method(total)
_for i _over range(1,total)
_loop
_loopbody(i)
_endloop
_endmethod

 _for i _over 
test_iter.iter_method(5)
_loop
show(i)
_endloop

1
2
3
4
5

 animals <<_iter _proc()
_loopbody(:cow)
_loopbody(:cat)
_loopbody(:rat)
_loopbody(:tiger)
_endproc


 _for i _over animals()
_loop
show(i)
_endloop


:cow
:cat 
:rat 
:tiger


* Day 13
** Advanced collection classes
** equality_set is "less strict in how it respects its object" or "less strict in what it considers an object" (it doesnt need to have the same addess to be considered the same "object")
#+begin_src magik

  my_s << set.new_with("abc","abc")
  # ===== sw:set(2)

  my_eqs << equality_set.new_with("abc","abc")
  # ===== sw:set(1)

#+end_src


** An interesting and useful function to test for this is .includes?()

#+begin_src magik
  
  my_s.includes?("abc")
  # ===== False

  my_eqs.includes?("abc")
  # ===== True

#+end_src



** Identity is basically the default consideration in magik

#+begin_src magik

  b << bag.new_with(1,2,1,2,5,2.5,2.5,"rpc","rpc")
  print(b)
  ## bag:
  # 2 1 
  # 2 2 
  # 1 5
  # 1 2.5
  # 1 2.5 
  # 1 "rpc" 
  # 1 "rpc" 

#+end_src

** Stack
*** you know this one. very cool as usual
** sorted_c
*** when we create a new sorted_collection. Always need a procedure. Or if build in pocedure, needs first number  (although not expected)
#+begin_src magik

  sort2 << sorted_collection.new(9, :strings_with_numbers)

  # ==========

  dec << _proc(a,b)
		 >> a _cf b
	 _endproc


  proper_sort << sorted_collection.new(8,dec)

  # ===== we always need a first number

#+end_src


** weak set
#+begin_src magik

  myrope << rope.new_with(9,7,9,6)

  myref << weak_reference.on(myrope)

  myrope.remove_nth(1)

  print(myref.referent)

  # rope(1,3):
  # 1 	7 
  # 2 	9 
  # 3 	6


#+end_src


** A cool but difficult trick in Magik that reminds me of Common Lisp mapcar
*** We should explore this
#+begin_src magik

  "25,55,55".split_by(%,). map(_proc(a) >> (a.as_number()/255.0) * 100 _endproc)

#+end_src

* Day 15
** try catch and throw (with maybe handling) is very confusing. I STILL dont get it. 
** But I did manage to get this

#+begin_src magik

  sometest << _proc @sometest()
		      _try
			      _with cond
			      condition.raise(:my_error,:location,"sometest")
		      _when my_error
			      write("my_error occured")
			      cond.report_on(!error_output!)
		      _endtry
	   _endproc


#+end_src

* Day 16

** Should write about this one. And really test this. Uses databus and highlight plugin

_block
    app << smallworld_product.applications.an_element()

 

    vw << gis_program_manager.databases[:electric]

 

    scanner << vw.geometry_scanner(:general)

 

    # get the bounding box defined by the trail
    bd << app.databus.request_data(:map_trail)[2].bounds

    # start the scanner with the bounds
    scanner.start_scan(bd)

 

    # now define a loop to retrieve all the geometry
    _loop 
          geom << scanner.get()

          # test for end of geometry 
           _if geom _is _unset _then _leave _endif

 

           # Write the scanned objects on the magik prompt
           write("+++ Scanned Objects +++",geom.rwo)

 

           # code here to process the geometry - for example 
           _if geom.rwo.rwo_type _is :eo_service_point
           _then
            app.databus.make_data_available(:geometry_to_highlight, geom)
           _endif
    _endloop
_endblock


* Day 17
** I dont understand threading. Actually, I understand a bit, but the engine concept and dependent seems unrelated. Its just an example. Dont get confused.

#+begin_src magik
  def_slotted_exemplar(:my_engine,

		      {{:slot1, _unset
		       }},:engine_model)

  # ==========

  _method my_engine.new()
	  ## 
	  ## 
	  >> _clone.init()
  _endmethod


  # ==========

  _method my_engine.init()
	  ## 
	  ## 
	  _super.init()
	  >> _self
  _endmethod

  # ==========

  _method my_engine.call()
	  _self.run_engine(_thisthread.background_priority, 
			   :sillycall|()|) 
  _endmethod

  # ==========

  _method my_engine.sillycall()
	  ## 
	  ## 
	  _self.changed(:engine_started)
	  _for i_cnt _over 1.upto(5)
	  _loop
		  _self.changed(:engine_running)
		  _thisthread.sleep(1000)
	  _endloop
	  _self.changed(:engine_stopped)
  _endmethod


  # ==========
  def_slotted_exemplar(:my_plugin,
	  {{:engine, _unset}},:plugin)

  # ==========

  _method my_plugin.new()
	  ## 
	  ## 
	  >> _clone.init()
  _endmethod

  # ==========

  _method my_plugin.init()
	  .engine << my_engine.new()

	  .engine.add_dependent(_self)
	  >> _self
  _endmethod

  # ==========

  _method my_plugin.call_engine()
	  .engine.call()
  _endmethod

  # ==========

  _method my_plugin.note_change( who, 
				 what, data )
	  ## 
	  ## 
	  _if what _is :engine_started
	  _then
		  write("!! Engine started !!, notification received from engine")
	  _elif what _is :engine_running
	  _then 
		  write("!! Engine running !!, notification received from engine")
	  _elif what _is :engine_stopped
	  _then
		  write("!! Engine stopped !!, notification received from engine")
	  _endif 
  _endmethod


  # ==========
#+end_src





** Holy fuck Im a genius. I discovered a cool trick. Well, kind of. Not sure how common, useful or easy-for-others (which is also the point, if its too weird, then its useless). Write this one down properly. I dont know. Maybe its just funny.

#+begin_src magik

  # ==========
  roper << _proc @roper(rope1,element1)
		   rope1.add(element1)
	_endproc
  # ==========

  _global addtorope << _proc @addtorope(inrope)
			       >> _proc @message(inelement)
					  _import inrope
					  write("feeding element", inelement, "into rope")
					  print(inrope)
					  >> roper(inrope,inelement)
				  _endproc	      
		       _endproc

  # ==========
  rope_test << rope.new_with()
  # ==========
  addperson << addtorope(rope_test)
  # ==========
  addperson(2)
  # ==========
  addperson(3)

  # ========== output ==========
  # Magik> print(rope_test)
  # rope(1,2):
  # 1 	2 
  # 2 	3

#+end_src

** Examples of my own question


#+begin_src

Question 1:
if its a helper function then we can clearly create multiple constants. That would save a TON of time. lets say it accepts 2 ropes as inputs. and the textual function itself adds whatever element we have into those 2 functions.


This is kinda useless, but who cares.


Question 2:
another function that accepts 2 ropes at first, to establish that functino. Then we create a textual function that display when we pass an argument to it, in which rope ists, in which it doesnt of the 2 ropes.

scratch that. We now use equality_set instead of rope.
  
#+end_src



#+begin_src magik

  _global mydualsearch << _proc @mydualsearch(eset1,eset2)
				  write("creating a meta function")
				  >> _proc @mysearch(element)
					     _import eset1
					     _import eset2
					     write("searching eset1 and eset2")
					     _if eset1.includes?(element)	    
					     _then
						     write("the first set has it!")
					     _else
						     write("set 1 doesnt have it, adding....")
						     eset1.add(element)
					     _endif
					     _if eset2.includes?(element)
					     _then
						     write("the second set has it")
					     _else
						     write("set 2 doesnt have it, adding it...")
						     eset2.add(element)
					     _endif
				     _endproc
		       _endproc

#+end_src



* Day 18
** Post mortem
*** New version behaves different. you need to generate a .jar file from module, before you can garbage collect (I think so.....)
** A way to test private function, without going through the whole process of creating an object

#+begin_src magik

    remex(:test_sys)
  $


  _pragma(classify_level=basic, topic={test}, usage={test})
  def_slotted_exemplar(:test_sys,
	  ## 
	  ## whatever
	  ## 
	  {{:first,unset}},:plugin)
  $


  # Why is it so easy to forget that _clone part?? There is
  # another way to do it, but I keep forgetting this method
  _pragma(classify_level=basic, topic={test}, usage={test})
  _method test_sys.new()
	  ## 
	  ## 

	  >> _clone.init()
  _endmethod
  $

  _pragma(classify_level=basic, topic={test}, usage={test})
  _method test_sys.init()
	  ## 
	  ##

	  .first << "haha"
	  >> _self 

  _endmethod
  $




  _private _method test_sys.useless() 
	  # Yields a NUMBER of random integers from 0 to RANGE - 1 

	  write("hello there")

  _endmethod
  $


  # ====================

  wow << test_sys.new()

  # ====================

  wow.sys!perform(:useless|()|)

  # ====================

#+end_src

* My examples (special variable _import and functional language)

** First we can actually feed a method into another method. Crazy!!

#+begin_src magik

  in_method << _proc @in_method(somestring)
		       write(somestring)
	    _endproc

  out_method << _proc @out_method(somefunc,astring)
			somefunc(astring)
		_endproc

  # Magik> out_method(in_method,"hello there")


#+end_src

** The first is using our variable of interest. So we simplify function. Example: simplifying add_to_rope(rope1, "asd") to add_to_rope1("asd")
#+begin_src magik

    # ==========
  roper << _proc @roper(rope1,element1)
		   rope1.add(element1)
	_endproc
  # ==========

  _global addtorope << _proc @addtorope(inrope)
			       >> _proc @message(inelement)
					  _import inrope
					  write("feeding element", inelement, "into rope")
					  print(inrope)
					  >> roper(inrope,inelement)
				  _endproc	      
		       _endproc

  # ==========
  rope_test << rope.new_with()
  # ==========
  addperson << addtorope(rope_test)
  # ==========
  addperson(2)
  # ==========
  addperson(3)

  # ========== output ==========
  # Magik> print(rope_test)
  # rope(1,2):
  # 1 	2 
  # 2 	3
  
#+end_src
** The second is feeding a function as a argument.


#+begin_src magik

  internal_writer << _proc @internal_writer(item)
				  write(item)
			  _endproc


  _global external_method << _proc @external_method (somefunc)
					  >> _proc @internal (mystring)
						   _import somefunc
						     somefunc(mystring)
					     _endproc
				  _endproc



  # Magik> test_writer << external_method(internal_writer)

  # Magik> test_writer("hello there")


#+end_src

* Day 19
** Application architecture
*** ========== Mostly a reminder of what we did in the past. But I still cant fully grasp strangely

smallworld_product.application(:sweo_dm_user).plugin(:maps).current_map.current_selection

*** The actual location of the .db itsewlf (.jou generates when we use an app accessing it)
**** E:\SmallWorld\electric_office\example_db\ds\ds_electric
*** We need to read about SOC (Spatial Object Controller), how it manages many data sources (from files to databasesa)
** Getting the databus datatypes
write(""); write(""); smallworld_product.application(:sweo_dm_user).databus_consumer_data_types[2]
** Try selecting several types of object in the map. and get the selection like this
smallworld_product.application(:sweo_dm_user).plugin(:maps).current_map.current_selection
** Exercises
*** Through the editor manager plugin we can get the current selected object
*** Select multiple objects in map manager. show the result in the explorer window
** Lists coz we have no clue what we're doing

#+begin_src magik


  smallworld_product.application(:sweo_dm_user).databus_consumer_data_types[2]
  smallworld_product.application(:sweo_dm_user).plugin(:maps).current_map.current_selection
  smallworld_product.application(:sweo_dm_user).plugin(:editor_manager)

  # from Syed
  _block
	  swapp << smallworld_product.application(:sweo_dm_user)
	  #print(swapp)
	  #print_ancestry(smallworld_product)
	  #swapp.report_plugins()
	  print(swapp.plugin(:maps).current_map.current_selection.rwo_set())
  _endblock
  
#+end_src

** 

* Day 20
** Only the first layer is raster image. Above that we can have state info, district info, operation layer. ACE can configure what users can see and cannot see
** Version management (TNB)
*** CPP
**** design work
**** electric
*** SNC
**** GIS
**** electric
*** Asset registration
**** land
**** design work
** Exercise (This is a lot to take in). This one is to merely tp teach predicates. But note the many details here
#+begin_src magik

  _block
	       _local gis_db << gis_program_manager.databases[:electric]
	       _local sw_eoapp << smallworld_product.application(:sweo_dm_user)
	       _local sw_eoapp_plmaptrail << sw_eoapp.plugin(:map_trail)
	       _local pseudo_geom << sw_eoapp_plmaptrail.current_trail.as_pseudo_geometry

	       _local pred1 << predicate.interacts(:location,pseudo_geom)
	       _local pred_coll << gis_db.collections[:eo_service_point].select(pred1)

	       _for item _over pred_coll.fast_elements()
	       _loop
		       write(item)
	       _endloop
       _endblock
  
#+end_src
** The same thing, but this time for cable_segment. We cant the geometry type (this time its :route) from the editor pane in the app.

#+begin_src magik

  _block
	       _local gis_db << gis_program_manager.databases[:electric]
	       _local sw_eoapp << smallworld_product.application(:sweo_dm_user)
	       _local sw_eoapp_plmaptrail << sw_eoapp.plugin(:map_trail)
	       _local pseudo_geom << sw_eoapp_plmaptrail.current_trail.as_pseudo_geometry

	       _local pred1 << predicate.interacts(:location,pseudo_geom)
	       _local pred_coll << gis_db.collections[:eo_cable_segment].select(pred1)

	       _for item _over pred_coll.fast_elements()
	       _loop
		       write(item)
	       _endloop
       _endblock
  
#+end_src
** We can list all state/city areas using
#+begin_src magik

  _for item  _over gis_db.table_for_external_name("Layout Area").fast_elements()
       _loop
	       write(item.name)
       _endloop
       
#+end_src
** You can also get the above from zoomin out in the app. And look for Layout Area in the object collection drop-down.
#+begin_src magik

  _block
	  _local gis_db << gis_program_manager.databases[:electric]
	  _local sw_eoapp << smallworld_product.application(:sweo_dm_user)
	  _local layout_area_coll << gis_db.collections[:layout_area]
	  _local pseudo_geom << layout_area_coll.at(1220618).area
	  # _local sw_eoapp_plmaptrail << sw_eoapp.plugin(:map_trail)
	  # _local pseudo_geom << sw_eoapp_plmaptrail.current_trail.as_pseudo_geometry

	  _local pred1 << predicate.interacts(:location,pseudo_geom)
	  _local pred_coll << gis_db.collections[:eo_service_point].select(pred1)

	  _for item _over pred_coll.fast_elements()
	  _loop
		  write(item)
	  _endloop

  _endblock

#+end_src

** Some notes
*** the layout_area_coll.at(1220618) looks like this in apropos. method at( gather keys_list) in dd_collection_mixin
*** 
** Rearrange later

#+begin_src magik

  _block
           _local ds << gis_program_manager.databases[:electric]
           #_local app << smallworld_product.application(:sweo_dm_user)
           _local layout_area_coll << ds.collections[:layout_area]
           _local ps_area << layout_area_coll.at(1220625).area

           a_scanner << ds.scanner_for({:sw_gis!area, :sw_gis!chain, :sw_gis!point}, ds.world)

 

           _for a_geom _over a_scanner.elements_within_coord_box(ps_area.bounds) 
        _loop
            write(a_geom.rwo)
        _endloop

_endblock

#+end_src


* Day 21
** A service point is a heterogenuous collection of data points. (??)
**

#+begin_src magik

  sw_app << smallworld_product.applications.an_element()

  an_rwo << sw_app.database.rwo_set()

  a_coll << an_rwo.select(:collection,{:eo_service_point})

  a_coll.size

  a_coll.an_element().transformer

  print(a_coll.an_element())

  
#+end_src
** Note that the transfomer is a single join (note the icon). And the sevice connection is a multi join (note the icon & also the select_collection(eo_service_connection), others like circuit_section show a db_set, basically a collection of records).
** Note the icons in the GUI. And here are the fields
*** physical field
*** enumerated field
*** join field
*** logical field
*** intergration field
*** catalogue field
** Basically below gets a record. Note the id inside ()
#+begin_src magik

    _for a_rec _over a_coll.an_element().circuit_and_section.fast_elements() _loop write(a_rec) _endloop

  # so we can the record intself

    gis_program_manager.databases[:electric].collections[:eo_circuit].at(314122)

#+end_src
** Reverse searching as practice
#+begin_src magik

    gis_program_manager.databases[:electric].collections[:eo_service_point].an_element().location

  # this will get the geometry information

  # if were to reverse search the record (object) itself from geometry infromation we do this

  gis_program_manager.databases[:electric].collections[:sw_gis!point].at({353475442,1057561421,888922}).rwo

  # note the symbol which allows us to :sw_gis!point to get all points data, so collections[:] has some interesting search capability?

#+end_src


** We do the same for cable segments. Keywords: cable segment, route, chain
**

#+begin_src magik

  _for i _over gis_program_manager.databases[:electric].collections.fast_keys()
  _loop
	  write(i)
  _endloop
  # this, we get eo_cable_segment_inst

  gis_program_manager.databases[:electric].collections[:eo_cable_segment_inst].an_element().route
  # we get chain:(gis_id(352321536,0,4687))


  gis_program_manager.databases[:electric].collections[:sw_gis!chain].at({352321536,0,4687}).rwo`




#+end_src

** (Later need to test this theory). Instead of collections[:], we can use select() with an rwo & combine with predicate to make it more flexible

#+begin_src magik


  an_rwo << sw_app.database.rwo_set()
  
  an_rwo.select(predicate.like(:status, "Existing"))  # can check .size

  # can use some weird almost Regex like thing. Coz like() is flexible


  an_rwo.select(predicate.like(:status, "%xistin%"))
  an_rwo.select(predicate.like(:status, "%xistin%")).size
 # the same size as results before


#+end_src

** By field types!! So it will display several records

#+begin_src magik

  print(an_rwo.select(:field,{:route}))

  print(an_rwo.select(:field,{:area}))

#+end_src

** For geomertry sets, a new app

#+begin_src magik


  geom_set << sw_app.geometry_set_factory()

  geom_set.get_geometry_set_for(:|EO|,gis_program_manager.databases[:electric].world)



#+end_src

** There are many others of interest
*** get_application_world(universe_name_id, world_name_id)
*** you can get information on world from

print(gis_program_manager.databases[:electric].world)
*** and




print(gis_program_manager.databases[:electric].world.universe)


app_world << geom_set.get_application_world_for_world(gis_program_manager.databases[:electric].world)


app_world.worlds
# this will show 8 internal worlds, for the 4 dataset that have an external and internal world



print(geom_set.get_display_styles_for(:|EO|))
# View -> View Properties -> Display Style (dropdown)
** There are many ways to extract the same set of information in Magik. Note that these 2 evaluate to True when we use _is
*** gis_program_manager.databases[:electric].rwo_set().select(:collection,{:eo_cable_segment_inst})
*** sw_app.database.rwo_set().select(:collection,{:eo_cable_segment_inst})

* Day 22
** We are creating a new project. The process always goes
*** zoom in onto a desired object. To restrict our project. IN our case we used service point (get and goto)
*** We create a new design
*** we change state to "as built changes"
*** 
** Inserting a record. and the changes reflected automatically in our GUI app. Example:
#+begin_src magik

  _block
	       _local ds << gis_program_manager.databases[:electric]
	       _local a_coll << ds.collections[:eo_service_point]
	       _local our_app << smallworld_product.application(:sweo_dm_user)
	       !current_application! << our_app
	       _local a_map_trail << our_app.plugin(:map_trail).current_trail
	       _local l_point << a_map_trail.as_pseudo_geometry  
	       _local l_prop << property_list.new_with(:status,"Existing",
							:network_type,"LV",
							:phasing,"A",
							:owner_type, "Company Owned",
							:owner_name,"GE West",
							:remarks,"a new insert from Ardie",
							:location, l_point)
		mytransaction << record_transaction.new_insert(a_coll, l_prop, "some comment")
		mytransaction.run()

       _endblock

#+end_src
** We are cloning a record. But make sure we give a location, coz searching that is possible. but our GUI cant locate it to show it
** Now, we are updating a record

#+begin_src magik

  _block
	       _local ds << gis_program_manager.databases[:electric]
	       _local a_coll << ds.collections[:eo_service_point]
	       _local our_app << smallworld_product.application(:sweo_dm_user)
	       !current_application! << our_app
	       _local a_map_trail << our_app.plugin(:map_trail).current_trail
	       _local l_point << a_map_trail.as_pseudo_geometry  
	       _local l_prop << property_list.new_with(:remarks,"ardies update successful",
							:network_type, "MV",
							:phasing,"ABC")

		mytransaction << record_transaction.new_update(a_coll.an_element(), l_prop, "some comment")
		mytransaction.run()
		
       _endblock

#+end_src
** How do we delete our selection??
#+begin_src magik

  _block
	       _local ds << gis_program_manager.databases[:electric]
	       _local a_coll << ds.collections[:eo_service_point]
	       _local our_app << smallworld_product.application(:sweo_dm_user)
	       !current_application! << our_app
	       _local a_map_trail << our_app.plugin(:map_trail).current_trail
	       _local l_point << a_map_trail.as_pseudo_geometry  
	       _local l_prop << property_list.new_with(:remarks,"ardies update successful",
							:network_type, "MV",
							:phasing,"ABC")



		mytransaction << record_transaction.new_delete( smallworld_product.application(:sweo_dm_user).plugin(:maps).current_map.current_selection.an_element().rwo, "some comment")
		mytransaction.run()

       _endblock
  
#+end_src
** Dataset transaction.
** First we select 3 and get thir ID.

#+begin_src magik

      smallworld_product.application(:sweo_dm_user).plugin(:maps).current_map.current_selection.an_element().rwo

      # note how an_element() needs to be used like previous Eg. Apparently, an_element(). is more than just "getting the first record".

       _for i _over smallworld_product.application(:sweo_dm_user).plugin(:maps).current_map.current_selection.fast_elements()
    _loop
	    write(i.rwo)
    _endloop

  #   eo_service_point28219:(648435)
  # eo_service_point28219:(648437)
  # eo_service_point28219:(648436)


    _block
	       _local ds << gis_program_manager.databases[:electric]
	       _local a_coll << ds.collections[:eo_service_point]
	       _local our_app << smallworld_product.application(:sweo_dm_user)
	       !current_application! << our_app
	       _local a_map_trail << our_app.plugin(:map_trail).current_trail
	       _local l_point << a_map_trail.as_pseudo_geometry  
	       _local l_prop << property_list.new_with(:remarks,"ardies update successful",
							:network_type, "MV",
							:phasing,"ABC")

		trans_rope << rope.new_with()					
		_for i  _over {648436,648437,648435}.fast_elements()
		_loop
			rt << record_transaction.new_delete(a_coll.at(i),"delete")
			trans_rope.add(rt)
		_endloop

		dt << dataset_transaction.new(trans_rope,"delete")

		dt.run()

       _endblock



#+end_src

** 

* Day 23
** Im lagging now
** If you want to really understand, regarding the physical_fields, and Geom_fields, and other types of fields

#+begin_src magik


  rwos << prof_app.database.rwo_set()

  rwos.source_descriptors()

  rwos.source_field_descriptors()

  

#+end_src
** WHat exactly is describe_trigger?

#+begin_src magik

  rwos.select(:collection,{:eo_service_point}).an_element().describe_triggers()

  
#+end_src
** PLEASE!! Try and complete this one out later
#+begin_src magik

  _block
sw_app
pl_map
a_map_view << pl-map.current.new_view()
a_map_view.set_view(pl_map.current_map_view.current_view_parameters())
f << frame.new("RPS training test canvas")
c << canvas.new(f,400,400)
f.activate()
a_map_view.set_rendering_surface(c)
a_map_view.render()
_endblock
  
#+end_src
** Pretty cool. This will definitely work

#+begin_src magik

  _block
app << smallworld_product.applications.an_element()
mapman << app.plugin(:maps)
a_map_view << mapman.current_map.new_view()
a_map_view.set_view(mapman.current_map_view.current_view_parameters() )
docman << app.plugin(:document_manager)
mgf << map_gui_framework.new( :test, app, :map_manager, mapman, 
:document_manager, docman, :resource_module_name, :map_plugin,
:floating_gui_definition_file_name, "floating_map_gui.xml",
:embedded_gui_definition_file_name, "embedded_map_gui.xml" )
mgf.activate(_unset, "RPC TEST MAP FRAMEWORK")
mgf.document << a_map_view
a_map_view.render()
_endblock

#+end_src
** Next class, we can create simple GUI window/frame by inheriting :model (more simple). We can configure actions too. 
** NOTE-TO-SELF:

#+begin_src magik

    !print_float_precision! << 10

    # ========== to increase precision point, so that, we can have our coordinates properly, to feed into ---> 
    # our_app.plugin(:map_trail).current_trail.add_geom(se)

#+end_src

* Day 24
** GUI Frameworek --> customize framework --> activation plugin --> GUI plugin --> model/engine model
** How a plugin (producer) pushes data into a databus. NOTE: the following example will NOT work. even if you replace _self correctly. 

#+begin_src magik

  _self.databus.make_data_available(:set_map_selection,
				   {cur_map, geom_set})

  # :set_map_selection is a data_type_name

  _method selection_reporter_plugin.sw_databus_data_available( data_type_name,
							       data )
	  _if data_type_name _is :map_trail
	  _then
		  (a_map, a_trail) << ( _scatter data )
		  .map_trail << a_trail
	  _endif
  _endmethod

  

#+end_src

** Applied example

#+begin_src magik

  _block
	  _local app << smallworld_product.applications.an_element()
	  _local po_set << rope.new_with()
	  _for a_set _over app.sys!perform_iter(:databus_request_all_data|()|, :map_selection)
	  _loop
		  po_set.add(a_set)
	  _endloop
	  print(po_set[1])
  _endblock

#+end_src
** Creating action objects

#+begin_src magik

  sw_action.new( :clear,
	       :image, { :clear, :ui_resources },
	       :engine, _self,
	       :action_message, { :current_object|<<|, _unset } )

  # you either mention the :clear in message files along with
  # filenames. OR you can mention file by filename.



#+end_src

** Process on how to see electric trace, and see cable segments connecting it
*** As usual, in your editor, get the first instance of a service point object. Make sure to select it
*** click Electric Trace. Switch direction to Upstream, since this is a Service Point. 
*** Click Go To in that floating Window itselc
*** Click to Explorer. CLick Network Analysis, to see all cable segments connecting it.
* Day 25
** Today we are loading using a module manager
#+begin_src magik



  sw_module_manager.load_standalone_module("c:/Users/ahmadardie.r/Documents/my-trash/magik_practice/2023-08-15_at_10hours/rpc_example")

  a << rpc_example_activation_plugin.new()

  a.activate_dialog()

  # ========== if you wanna see all loaded modules, including your own

  sw_module_dialog.open()


#+end_src
** Once again, not to self, when searching for field names. Do this (example):

#+begin_src magik
  
  _for item _over pl_map.current_map.database.collection(:electric,:eo_service_point).all_field_names() _loop
														write(item)
										     _endloop

#+end_src

* Day 26
** writing to an XML, for selected objects
#+begin_src magik

  _global write_map_selection_to_xml <<_proc@ write_map_selection_to_xml(a_xml_file)
					       # Get the first app ( not a good idea, but will be ok for demo)
					       _local an_app << smallworld_product.applications.an_element()
					       _local map_mgr << an_app.plugin(:maps)
					       _local curr_sel << map_mgr.current_map.current_selection
					       sub_ele_rope << rope.new()
					       _for each_geom _over curr_sel.fast_elements()
					       _loop
						       a_rec << each_geom.rwo
						       _if a_rec.rwo_type _is :eo_service_point
						       _then
							       a_name << a_rec.usage.write_string
							       sub_ele_rope.add_last( simple_xml_thing.new(a_rec.rwo_type,_unset,{:usage,a_name}))
						       _endif
					       _endloop
					       # Create a top level xml element
					       top_level_xml_ele << simple_xml_thing.new(:selected_records,
											 sub_ele_rope)
					       simple_xml.write_element_file(a_xml_file, top_level_xml_ele )
				     _endproc

  # ========== and then run it

  write_map_selection_to_xml("c:/Users/ahmadardie.r/Desktop/whatever.xml")

#+end_src
** The example above, test the simple_xml_thing(). it essentially creates a tag like structure, with attributes (like <h1 color="red"></h1>)
** Make sure to edit the one below
#+begin_src magik

  _global show_xml_content <<
  _proc@show_xml_content( a_xml_file)
	  a_xml_doc << simple_xml.read_document_file(a_xml_file)
	  _for each_ele _over a_xml_doc.elements.fast_elements()
	  _loop
		  _for each_sub_ele _over each_ele.elements.fast_elements()
		  _loop
			  an_name << each_sub_ele.xml_attributes["name"]
			  write("RWO ",each_sub_ele.type," with Name ",an_name)
		  _endloop
	  _endloop
			   _endproc

#+end_src
** serial_xml_thing practice
#+begin_src magik

  _global write_map_selection_to_xml <<_proc@ write_map_selection_to_xml(a_xml_file)
					       # Get the first app ( not a good idea, but will be ok for demo)
					       _local an_app << smallworld_product.applications.an_element()
					       _local map_mgr << an_app.plugin(:maps)
					       _local curr_sel << map_mgr.current_map.current_selection
					       rope1 << rope.new()
					       _for each_geom _over curr_sel.fast_elements()
					       _loop
						       a_rec << each_geom.rwo
						       rope1.add(a_rec)
					       _endloop
					       # Create a top level xml element

					       a_xml << serial_xml_thing.write_thing_to(rope1, a_xml_file)
				     _endproc

  # ========== and then run it

  write_map_selection_to_xml("c:/Users/ahmadardie.r/Desktop/whateverSerial.xml")


#+end_src


** Now read it as-is, no changes

#+begin_src magik

xml_read << serial_xml_thing.read_thing_from("c:/Users/ahmadardie.r/Desktop/whateverSerial.xml")

#+end_src

** From previous notes, our struggle to find the record is due to to this (please write this properly)
#+begin_src magik

print(sw_app.plugin(:maps).current_map.current_selection.an_element().rwo.source_collection.all_fields)

#+end_src

* Day 27
** No need selection. Answers to question 4
#+begin_src magik

  sw_app.plugin(:editor_manager).sys!slot(:embedded_viewer).sys!slot(:editors)[:|electric.eo_service_point|].current_object

    # when we print sw_app.plugin(:editor_manager) we get a listing including slots
    # can change it to cable segment or anything

#+end_src
** Note the usage of sys!slot is becoz the slots are private (we do the same thing with methods with sys!perform I thinik).
** Later must check make_geometry method. Apparently, a strategy is to add location later (after rt.run(), where rt is a record_transation). Its becoz location fields are not mandatory. And mandatory are usually common for all records. So one strategy is to create single property list for mandatory fields, and upload the rest (locations, etc..) from a .csv file
** For answer 5. if you were to use the bounds by itself, you'll only get 1 hypernode. But by increasing buffer, you get 5, as can be seen by the map

#+begin_src magik

  _block
	       _local a_ds << gis_program_manager.databases[:electric]
	       _local a_coll << a_ds.collections[:sub_substation]
	       _local all_hype << a_ds.collections[:eo_network_hypernode]
	       _local a_rec << a_coll.an_element()
	       _local sw_app << smallworld_product.application(:sweo_dm_user)
	       _local curr_map << sw_app.plugin(:maps)
	       curr_map.get_active_map_view().goto(a_rec)
	       _local a_extent << a_rec.extent
	       _local p1 << predicate.interacts(:pin1,a_extent)
	       _local p2 << predicate.interacts(:pin2,a_extent)
	       _local results << all_hype.select(p1 _or p2)
       _endblock

#+end_src

** Proper answer

#+begin_src magik

  _block
	  _local a_ds << gis_program_manager.databases[:electric]
	  _local a_coll << a_ds.collections[:sub_substation]
	  _local all_hype << a_ds.collections[:eo_network_hypernode]
	  _local a_rec << a_coll.an_element()
	  _local sw_app << smallworld_product.application(:sweo_dm_user)
	  _local curr_map << sw_app.plugin(:maps)
	  curr_map.get_active_map_view().goto(a_rec)
	  _local a_extent << a_rec.extent

	  _local a_pseudo_area << pseudo_area.new_for_world(a_extent,a_ds.world)
	  _local a_buffer << a_pseudo_area.buffer(5000)
	  a_buffer.world << a_ds.world
	  _local p1 << predicate.interacts(:pin1,a_buffer)
	  _local p2 << predicate.interacts(:pin2,a_buffer)
	  _local results << all_hype.select(p1 _or p2)
	  print(results)
  _endblock

#+end_src

** unit conversion

#+begin_src magik

  unit_value.new().value_in()

  unit_value.new(20,:feet).value_in(:mm)

#+end_src

* Day 28
** If we open Suite Admin -> Ace Config -> (select EO) Object Properties -> We get to see visibile feld (Electric DM -> ELectric -> Equipment -> Service Equipment)
** Was busy this day with Fiverr (huhuhu)
** 
* Day 29
** Coordinates systems
#+begin_src magik

  gis_program_manager.databases[:electric].user_visible_coordinate_systems
  # heres another one
  gis_program_manager.databases[:electric].collections[:eo_service_point].an_element().location.coord.x

#+end_src

** Converting a coordinate

#+begin_src magik

  from_cs << gis_program_manager.databases[:electric].user_visible_coordinate_systems[:|British National Grid (mm)|]
  to_cs << gis_program_manager.databases[:electric].user_visible_coordinate_systems[:|Long-Lat WGS84 (degree)|]
  trans << transform.new_converting_cs_to_cs(from_cs, to_cs)

  sw_app << smallworld_product.application(:sweo_dm_user)
  a_coll << gis_program_manager.databases[:electric].collection(:eo_service_point)
  a_coord << a_coll.an_element().coordinate

  converted_coord << trans.convert(a_coord)

  sw_app << smallworld_product.application(:sweo_dm_user)

#+end_src

** Changing coordinate system

#+begin_src magik

# we havent tried this
  sw_app.projection <<
  application_coordinate_system.new_from(v.world.coordinate_system)

#+end_src

** Exercise 5 (?)
*** get objects from current window
*** for line or area, just list ID and status, no need for geom_x and geom_y
* GUI Practice
** Key words to searh for in core document
*** GUI control classes
*** Rearrange the following later based on control panel component (in core doc)
*** message group
*** GUI containers
*** Meal Menu example
** How to 
#+begin_src magik

  ==============================
e
an_action << sw_action.new(:sample1, :caption, "just a sample")
control_panel_component.add_control_panel_action(an_action,
						 :comment, "some comments"
			)
control_panel_component.add_event_handler(:action_selected, _self, a_method)

# we create the GUI. add a control for the action

_pragma(classify_level=basic, topic={test}, usage={test})
_method my_component.activate_in(frame)
	## 
	## 
	top_container << rowcol.new(frame, _unset,1
				:row_aligment, "whatever"
				:col_alignment, "whatever-lah")
	button_1 << button_item.new(top_container,"press me")

	.self.action(:views).place_control_on(button_1)
	.self.build_gui(pw,:width, 155, :height, 350)
	
_endmethod
$

#+end_src
* Day 30
** We're learning authorixation, not much code this time
**
#+begin_src magik

  print(gis_program_manager.authorisation_view.current_groups)
  print(gis_program_manager.authorisation_view.current_user)

#+end_src
** enumerator (extensible enumerator)
#+begin_src magik
  print(gis_program_manager.databases[:electric].collections[:eo_service_point].field(:status))
# and check :type dd_field_type(eo_status) . it will be the same as show in extensible enumerator under the admin suite

#+end_src
* Recent tricks
** Instead of losing code through mountains of lines and errors. I recently did this

#+begin_src magik

  _for i _over a_coll_sp.an_element().physical_fields()
  _loop
	  write(i)
  _endloop
  a_coll_sp.an_element().raw_values_as_vector()[1]
  print(a_coll_sp.an_element().cs_as_property_list())

#+end_src
* Day 31:
** We learned something about alternative and checkpoint management.
** A lot of interesting stuff but useless for now

#+begin_src magik
File usage for the current alternative:

------------------------------------------

_block
        _local ds << gis_program_manager.cached_Dataset(:electric)
    _local fle_usg << ds.file_usage(:this_alt_only?,_true)
    ds.dump_file_usage(fle_usg)
_endblock

 

File usage for all:

-------------------

_block
        _local ds << gis_program_manager.cached_Dataset(:electric)
    _local fle_usg << ds.file_usage()
    ds.dump_file_usage(fle_usg)
_endblock

#+end_src

** cached_dataset to get checkpoint information

#+begin_src magik

  ds << program.cached_dataset(:electric)
  print(ds.checkpoints[1])
  write(ds.checkpoints[1].user_name)
  write(ds.checkpoints[1].time_created)

  # ===== can also create current alternative info
  write(ds.current_alternative_details)

#+end_src

** 

* Day 32:
** We learned how to add a new field for the record "Service Point". 
** We opened the Case Tool and we zoomed into the service point. We added a new field. We did a "check" and "apply". we clicked update both in the ACE and outside. We make sure the checkpoint is writable (clicked through the Version Management inside ACE), before we commit with a new checkpoint name. We restarted the app to see the changes. 
** 
* Extra class/lessons
** select an object, right click & display internals (current map). This gets the internal world. And you can check the hypoernode (And clicking goto corresponding to pin1 and pin2 gets these)
* GUI practice and Databus
** What have we done so far
*** we discovered simple_list
*** we discovered identifier, which for some reason doesnt work
*** discovered accessing values from simple_list and moving them to a label_item
*** we discovered tree_item
** When in doubt, always go back to our Meal Menu example
** Some random coding
#+begin_src magik


  # dont know how I did this
  # this is probably for initializing before you do anything
  # useful with databuses
  pl_map.define_shared_constant( :databus_producer_data_types,
			       {whatnow, :record_selection}, :public)



  # this is pretty straightforward stuff
  pl_e.databus.request_data(:current_document)[1]



#+end_src

** Setting trail through databus, but inside a method

#+begin_src magik

  # To set the current map’s trail, your plugin must be registered with the application databus as a producer of the :set_map_trail data type:
  my_plugin.define_shared_constant( :databus_producer_data_types,
				  { :set_map_trail },
				  :public )
  # In the plugin, when you want to set the trail, use a method like this:
  _method my_plugin.set_trail( a_geometry )
	  _self.databus_make_data_available(:set_map_trail,
					    {_self, a_geometry})
  _endmethod
  # The geometry supplied on the databus is converted into simple linear geometry and then into a trail.


#+end_src

** Loading the standalone module, not always used in practice. But useful under some circumstances
** Loading a standalone module
#+begin_src magik

sw_module_manager.load_standalone_module("c:/Users/ahmadardie.r/Documents/my-trash/magik_practice/2023-09-04_at_16hours/rpc_example/")

#+end_src
** geometry_set_for_trace_drawing( nf_link )
** _self.application.databus.request_data( :trace_results )
** Terms:
*** Customizing the network analysis engine
*** The idea below may not be important

- create scanner (our_program.geometry_scanner(:point))

- create bounding box (.buonds)
start scanner  (.start_scan())
- get (.get())
-
node_at

pseudo_node.new_for_world(geom,:electric)

network_follower.trace_out(node1)

network_follower.shortest_path( node1, node2, _gather params )
* Topics:
** Magik components and conponent frameworks
** GUI Containers and Controls
** Alphabetical Document List
** Developing Interactive Applications
** Using the Application Framework Architecture
** Working with Geometry
* Databus more of it
#+begin_src magik

  an_element << gis_program_manager.databases[:electric].collections[:eo_service_point].an_element()

  a_geom << an_element.geometry_set(gis_program_manager.databases[:electric].world)

  pl_map.databus.make_data_available(:set_map_selection, {pl_map, a_geom, :add})

  pl_map.goto(a_geom)

#+end_src
* Read on VMDS from here:
** https://wiki.gis.com/wiki/index.php/VMDS
* How to clone the SmallWorld repo
** Make sure your endpoint security VPN is enabled and connected (your tray below), using staff password
** Download and install the Github Desktop app
*** [[https://redplanetsolutions.sharepoint.com/:u:/s/rpstnb/EeKnOrTrblNEminzerOFTjcB-RLhOIP5s1bUqSKz5BSlVw?e=bbusAw][Github Desktop]]
** Login below
*** http://192.168.3.66/users/sign_in
*** username and password 
*** Change to your desired password
** Login into Github Desktop with the new password
** Choose your desired directory/folder (can choose default, make sure its not the same as our previous SmallWorld)
* RWO (SmallWorld)
** they have 2 unique fields, rwo_type and rwo_code (a name and integer code). 
** RWO definitions - they are defined like tables (you can create it from Magik code)
** What are "Views on RWO"?
** RWO sets
*** It seems to be its own thing
*** heterogenuous (not from single source) set of records across collection and dataset.
*** ds_collection is also an RWO set
*** We can use predicate when searching in rwo_set
*** There is an RWO set API, all classes inheriting from dataset_collection_mixin implement RWO set API
*** Using predicate in RWO allows searching of fields regardless of dataset source.
#+begin_src magik

my_areas << my_rwos.select(:field, {:name})

#+end_src
* Alteia and self-learnt topics 
** Synonyms
*** Site = Project
*** 
** User roles 
*** Manager
**** Company manager has permission to create datasets
**** Domain manager can activate custom analytics
*** User
*** Contributor
*** Operator
** What is a survey
** CSV
*** We apparently are using the CSV file to localize the information 
*** Often in the form of
X, Y, Z
524510.928, 324634.025, 2.446
524524.29, 423585.665, 2.448
** Machine Learning in electric utilities (https://www.datarevenue.com/en-blog/machine-learning-for-energy-transmission)
*** Common risks used in energy transmission
*** prevent power grid failure
*** prevent brownouts with AI prediction
*** balance the grid
**** transmission operators spend millions each year fixing fixing planning mistakes (too much or too little power). Last correction either by buying more power, or compensating power plants for excess
**** Machine learning is the most accurate method available to forecast renewable energy output. Advanced method like Long Short-Term Neural Networks (LSTMs), AI can weigh many factors - wind, temperature, sunlight, humidity forecases, and make predictions
*** detect energy theft
*** differentiate power system disturbances from cyber attacks
#+begin_quote

pip install alteia

#+end_quote
*** use config-connection.json to store username and password and other configs, like public endpoint of Alteia, dictionary providing connection config
*** this is documented in 
*** configuration options documented in alteia.core.config.ConnectionConfig
*** the use case shown is rather specific. using a VERY simple Python script to calculate "fuel consumption" as a function of load, lenfth, and delta_z (elevation delta).
*** On adding custom analytics to end-to-end workflow. 
**** Example is Rust Detector
**** We need to use Docker for this
*** On Docker:
**** The process of creating is simple. Usually a config file just like alteia SDK
**** However reasons NOT to use Docker include: 
***** Building a small project. Becoz you dont need to host it. Docker involves several configs like Docker files and such. Which can make it complicated
***** Docker images are not entirely portable. A Docker build on Linux, still needs Linux to run. So we usually run it inside Linux virtual environment installed on Windows
***** Dockers are best for console-based apps, and even web apps. Not meant for Desktop apps with rich GUI
** Discovery
*** Upon exploring 1 site (FPL Satellite Demo), we discovered the compare tool
*** When comparing we discovered vegetation encorachment data
*** Vegetation management is expensive maintenance work for disctribution & transmission infrastructure. Interesting --> Data prediction usage is species identification and growth rates based on weather conditinos and precipitation rates
*** Traditionally we have always relied on combination of manual surveys and spatial assistance from remote sensing data
*** We now have deep leaning assisted workflows, using satelllite imagery, drone images, 3D data
*** LiDAR
**** It is frequently mentioned as a data source
**** https://www.jouav.com/case-study/lidar-mapping-malaysian-border-roads.html
**** Its basically like a bat sonar, but uses light pulses instead of sound waves
**** Malvus Sense Sdn Bhd -->  Locally unique challenges: Lots of rain, dense forests, places emphasis on waterproofness of drones and penetration of radar. Legal compliance of the flight (so deathly boring), apply for air space from Malaysian Sports Aviation Federation (MSAF), flight bandwidth to 1 km
**** Here ='s  good article on vegetation encroachment in a Malaysian context.
**** https://www.mdpi.com/1996-1073/14/12/3393
*** But LiDAR's are expensive, Satellite data can cover a wide area at a relatively low cost?
** Basic:
*** Energy basic is a complex network of power plants, transmission lines, substations, distribution lines
*** generation = creating electrical power from other forms of energy
*** transmission = moving this electricity from power plant to population centers using HV
*** distribution = delivery of power to individual houses/etc via LV
*** Energy grid operators are using AI in key areas:
**** asset management = AI enabled sensors identify issues befoe problems. Also, historical data, helps maintenance schedules
**** grid operations = real time monitoring of power flow
**** load forecasting = predicting future demans and customer behaviour
**** decision making = where to build new power plants
*** [[https://x2n.com/blog/how-utility-companies-are-using-satellite-technology/][Satellite datxsa]]
*** [[https://www.bloomberg.com/press-releases/2020-10-13/alteia-accelerates-the-deployment-of-its-enterprise-ai-solutions-and-announces-global-alliances-with-ge-digital-and-microsoft][Alteia joins forces]]
**** Alteia joins forces with Microsoft (bringing VI to Azure)
**** Alteia joins forces with GE Digital 
**** Alteia = technology specialist & GE Digital = vertical leader
**** predictive maintenance can capture knowledge?? Becoz staffs retire??
**** 
* Meeting (soon we might need to move meeting into its own place)
** https://www.scribd.com/document/388790080/Sparc-t8-m8-Servers-Faq-3864324
*** What is SPARC?
** I dont understand, haha??!!
** Sabah Energy!??
** TNB GIS CR
*** PNI -> Physical Network Inventory (Fibre??)
*** Active Centralized LV Database ??
*** 
** IQGeo accepts input from Smallworld - Posgres
*** provides telecom, fiber, and utility network operators with the industry's most innovative geospatial network management software solutions.
** Cliffhanger - Atlas (elastic search) accepts dataa from SmallWorld
*** elastic search
** Geomagic GeoNAM - 
*** Cathodic protection - Oracle
* Licensing:
** How do we know everything WITHOUT reading everything
** [[https://www.gegridsolutions.com/products/applications/geospatial/ger4240_oraclesolutions_r6.pdf][Smallworld Oracle]]
*** Smallworld On Oracle allows for the storage of all Smallworld spatial and non-spatial data within an Oracle environment
*** Oracle Spatial simple geometry type
**** point
**** polyline
**** polygon
*** Oracle Spatial is also used to manage address information
**** Notice the separate elements of address and the geographical location of the addresss
**** Address is considered non-spatial information, and is already present in exisiting enterprise system (Customer Relationship Management
**** This provides interesting solutions such as: linking a customers location to network for outage management
**** Seamless integration between Smallworld and Oracle through => publishing one way to Oracle (spatial data too) => 2-way sync between both
** GE Asset Management Products
*** Smallworld Core
**** 3 levels of using the app -> Core, View and Developer
**** full database access
**** Database technology -> direct, cached & replica
*** Developer license includes access to Case Tools
*** Core is usually for system admin, and Developer is FAR too advanced
*** Google Map Viewer
**** Its sold as annual subscription, per end user device (meaning no limit number of GE apps)
**** Smartphone
**** Laptop
**** PC
**** Server
* Links:
** [[https://www.pix4d.com/blog/ten-basic-terms-photogrammetry-knowledge/][pix4d]]
*** Initial and computed parameters => parameters like geometry, position & orientation => pix4d will actually produce computed ones which are more accurate. 3D models with accuracy within a few centimetres, it can reaach industry standards like Bureau Veritas, meaning more applications
*** RTK and PPK are GPS correction techniques
**** RTK happens during drones or survey, with a GNSS RTK receiver 
**** PPK complements lack-of-RTK or no tie points, with a GNSS base station. (both have pros and cons)
**** Tie point, point common in several images. No idea
**** Ground Samping Distance => fancy name for resolution, acheived by distance of flying to the ground
**** 
** [[https://learn.arcgis.com/en/projects/get-started-with-arcgis-drone2map/][ArcGIS Drone2Map]]
*** Drones take 2 types: Nadir (straight down) Oblique (angled)
*** Nadir images can be used to create 2D Orthoimages, several can be combined to create orthomosaics, to create basemaps
*** Oblique images => 3D point cloud => 3D Mesh => navigable 3D diagram
*** 
* Coordinate (also move to a different note)
** [[http://qgismalaysia.blogspot.com/2012/07/did-you-use-right-wgs84.html][did you use the right WGS84?]]
*** Has some interesting REAL LIFE details, including formulaes on converting coordinate systems
** [[https://epsg.io/?q=Malaysia&page=4][Check this out, combination of WGS and UTM]]
*** Whatever, just check it out
* Alteia upload
** When we upload a survey, we have yet tried the + METADATA option
** We need to read this one, then rewrite:
*** [[https://help.alteia.com/data-capture-and-ingestion/upload-csv-as-a-vector-file][upload CSV as a vector file]]
** 
