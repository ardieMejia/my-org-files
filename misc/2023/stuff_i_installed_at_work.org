#+OPTIONS: toc:nil

* Personal stuff I installed
** smallworld software strange that   its closed source
** Emacs 23, so boring coz its so old
** VirtualBox, Lubuntu
** PowerToys for keyboard shortcuts
** Git
* (Official) Stuff I did so far.
** Install Java
** we downloaded 3 files
** Emacs, emacs.rar (??), EO installer
** Moved it to E drive
** moved Emacs and extract at same level as SmallWorld
** run configure.exe as admin
** We also added some config to gis_aliases under core/config

#+begin_quote

emacs:
EMACSROOT    = E:\SmallWorld\emacs-28.2
title    = GNU Emacs 28.2
program    = %EMACSROOT%\bin\runemacs.exe
icon_file    = %SW_WHICH_GIS_ALIAS_PARENT_DIR%\bin\runemacs.exe
log_file    = nul:
product    = emacs
EMACSLOADPATH    = %EMACSROOT%\share\emacs\28.2\lisp; %EMACSROOT%\share\emacs\site-lisp
PATH    = %PATH%;%EMACSROOT%\bin
HOME    = %HOMEDRIVE%%HOMEPATH%

#+end_quote

** copy license -> message.ds under smallworld_registry
** Change file properties of EO_Demo (target, arguments like -a)

E:\SmallWorld\core\bin\x86\gis.exe -a "E:\SmallWorld\electric_office\config\gis_aliases" -e "E:\SmallWorld\core\config\environment.bat" emacs


** Run config program under core
** Had to add Everyone as new group at parent directory (SmallWorld), before anything happened. (Make sure permissions all set/allowed) Finally clicking "Show Licenses" finally worked 
** Start server if itsnt started
** also, under datastore server admin -> security -> add "rights all" at top -> commit
** also licenses -> show licenses -> (should show details)
* Learning progress (user)
** [%HOME%] runalias eo_open -login root
** We learned how to create a map, resize that map area & add a legend
** We learned how to update the state of the map (so it shows in green instead of red)
** There projections we can change, but we always us WGS projection, standard
** we learnt using the app manager (I dont remember what we did with the administration suite)
** "How to get help" will open the official help website
** ==================================================
** we learnt about object types, chains (line), points (raster?), area (polygon). Please fix this one.
** we can refresh the whole database, or the whole map
** Geometry
*** joint,valve,roundabout = point
*** cable,pipeline,road = line
*** substation,duct,park = area
*** name,length = annotation
*** background map, scanned image, surface model = raster
** File -> new project and design 
*** after creating details, always remember to say "no" to checking for overlap
** File -> Browser design -> "Design Browser"
*** we clear filter & and "run query"n to list all designs
** File -> New Checkpoint
*** When we go to app manager, and open suite admin, we can see our named version
*** I dont understand this part at all
** File -> State Model Viewer -> "shows the possible state paths"
** ==================================================
** We about design
*** DM_top is the upmost layer/object
*** When we first open we are presented with DM_top
*** We then create a new design
** We learnt the object editor
*** We learnt insert, update and delete a trail geometry
*** By adding a new trail, we can lock, highlight, and move-to. To navigate back to that point after some journey
*** There are mandatory fields
*** We forgot we can actually clear trail by right-clicking
** Object editor, we filed mandatory fields after creating trail (area), must fill extent, tick mark. Remark to update
** version management
*** We create a new checkpoint from the window
*** It has numbering naming system in the database, not our chosen name
***** Good names like, "before_delete", "before_update"
***** New alternative creates child checkpoints
***** Rollback and commit. rollback = undo to last changes. commit = save
** ==================================================
** dataset schema -> Collection (table) (Eg cable) -> Field (Records)
** UG OH MV HV lV
** visibility, selectibility, hitability
** copying properties for insertion?
*** select existing cable, create trail, select "geometry from trail", click "insert"
** Everytime, create new design, theres PLAN_*** in versiona management
* Wishlist:
** https://stackoverflow.com/questions/42566799/how-to-bring-focus-to-window-by-process-name
*** Basically write a Powershell script that switches focus to another app. Better idea is down below, to use Window name, instead of process name
* Rearrange:
** We need to rewrite inside GIMP.org or photoshop.org or ImageMagick.org or something
*** https://www.gimpusers.com/forums/gimp-user/3403-writing-values-to-a-file-from-within-gimp
** We need to recheck the code and write this somewhere in Emacs.org or something. But not sure if its eLisp or commonLisp
*** https://stackoverflow.com/questions/9495376/how-to-create-and-write-into-text-file-in-lisp
* Day1:
** gis_aliases under electric_office/config/gis_aliases, we can set 
** running core/config will start server
*** it is a 2 way communication
*** swmfs (data store server ) sits between DB and app (it is a 2 way communication)
*** supports real life update from mobile
*** from web, they will publish wms link
**** They cal it WMS 
**** https://enterprise.arcgis.com/en/server/latest/publish-services/linux/wms-services.htm
*** 
** managing SOC
*** run manage_soc()
*** under electric_dm, we open GIS, -> right click properties -> we click GIS -> ds -> files -> 1
*** 
** Based on the business process, when we create plans, it either creates for all 3 datasets (GIS, electric, etc..)
** 
*** Digitization
*** QAC
**** We have several routines
*** approval
**** 
*** ready for posting
*** posted - once posted to DM_TOP, we have a scheduler that syncs with WORKING_TOP
** Smallworld Framework Arch
*** We have classes for example for each actions, plugins, GUI framework & PLugin Framework
*** We need to add the changes to XML, before we see the changes?
** When creating GUI elements, like an option under a menu bar, 2 places need it defined:
*** E:\SmallWorld\electric_office\modules\application_modules\sweo_base_user_application\resources\base\data
*** Under this folder, config.xml registers the plugin, GUI.xml registers the menu bar
** Example commands:
*** print(smallworld_product.applications)
this will display
sweo_dm_admin_application(sweo_dm_admin_application) 
sweo_base_user_application(sweo_dm_user) 
*** command basically shows all applications under product
*** class browser get be opened using F3-F3
*** IN searches specific class (make sure its <loc>)
**** methods
**** classes
**** pragma flags
**** inheritance options
**** override options
*** Tab switch between searching for classes or methods
*** "/" clears the string
*** F3-<down> expands methods
*** F3-<up> contracts methods
* Day 2:
** you create a class using def_slotted_exemplar
print_heirarchy
print_ancestry

debug_print()

** Read and understand!!
*** class name
*** inheritance
*** local methods
*** inheritance methods
*** slots
*** what do object slot points to??
*** how to objects related to each other??
** More commands to check
write()
print()
show()
** key  (in key-value pair) and symbol are the same thing
** you can have 2 of the same symbols in a collectionq
** You can also enquire class_name on any variable, coz variable are objects!!
var1 << 234
var1.class_name
propert_list.new_with(:hello, "123", :hello, "567")
** apropos needs a bracket and ""
var1.apropos("")
** _block and _endblock is basically lambda (anonymous function) in lisp
** Like this
_block
		_local a << "123"
		_local b << "456"
	_endblock
** an actual function

test << _proc()
       	       _global haha
	       haha << 345
		_local a << "rty"
		_local b << "tyu"
	_endproc
** Dynamic variables
test2 << _proc()
       	     	_dynamic !var1! << "spiderman"
		write(!var1!)
_endproc

==========

test3 << _proc()
       	     	_dynamic !var1! << "nothing"
		test2()
		write(!var1!)

========== for unset variables

_if var2 _is _unset
       _then
		var2 << 345
	_endif
** loops
*** for loops
sv << {1,2,3,4,5,6}
_for i _over sv.fast_elements()
       _loop
		write(i)
	_endloop
*** for loops with range()
*** loop can have a name!!
*** In one example, a function (procedure) can have a different naming, but checking with class_name produces "global variable". So it may refer to return value
*** only hash tables behave like this, occupying the same memory address

ht << hash_table.new()
ht2 << ht
*** magik doesnt need format directive like lisp (%s)
** _pragma is to define class accessibility (restricted, basic, etc...)
** def_slotted_exemplar is to define a class
** remex is to remove class definitions before we recreate and recompile
** Ehan
*** representation in .shp files
**** polygon/area
**** line/chain
**** point
**** text/label/annotation
*** vhs
**** Related to display scale (some objects hidden or showed). Visibility, HIttability, Selectability
**** From admin -> ACE configuration -> object configuration
** Common beginner mistakes
*** Forgetting () after fast_elements
*** when create method for class (_pragma n then _method), putting  brackets dont matter, but 
*** putting () brackets after certain properties like size 
*** misunderstanding that cable_segment is actually a table (collection)
*** when getting collections from databases, putting [] brackets and () in the wrong places (need to know which is a method and which is not)
**** Like this
#+begin_src magik
  gis_program_manager.databases[:electric].collections[:eo_cable_segment_inst].field(:source_data)
#+end_src
**** Notice the collections[] is the table, whereas field is a function
*** When searching through plugins. the real name inside (). like this
a dm_construction_pack_plugin(construction_pack)
**** construction_pack is the real name
*** When apopos-ing we can come up with "slot" methods, we still use them like methods aka
plugin2.current_trail.geometry[1][1].x
**** geometry is named "slot" under apropos() but we use (.) like a method
* Day 3:
** using ! marks
#+begin_src magik

  gis_program_manager.databases[:electric]
  var1 << ! # ---------- gets the output value one line before which is value outputgis_program_manager.databases[:electric]
  var2 << !! # ========== gets the output value 2 lines before outputgis_program_manager.databases[:electric]

#+end_src

** getting database information
#+begin_src magik

  gis_program_manager.databases[:electric].table_for_external_name("Cable Segment")
  # you can also put size at the end
  gis_program_manager.databases[:electric].table_for_external_name("Cable Segment").size
  # you can also print the first record
  print(gis_program_manager.databases[:electric].table_for_external_name("Cable Segment").an_element())



  
#+end_src

** getting collection information
#+begin_src magik
  
  # you can even put the internal name of the collection
  print(gis_program_manager.databases[:electric].collections[:eo_cable_segment_inst].an_element())

  # getting available methods under colection
  # You forgot the name. You can "apropos" the methods available
  gis_program_manager.databases[:electric].collections[:eo_cable_segment_inst].apropos("nth")
  # then you get a certain nth record
  print(gis_program_manager.databases[:electric].collections[:eo_cable_segment_inst].nth_record(100))

  # Can use internal and external name
  print(gis_program_manager.databases[:electric].collections[:eo_cable_segment_inst].field_for_external_name("Source Data"))
  print(gis_program_manager.databases[:electric].collections[:eo_cable_segment_inst].field(:source_data))

#+end_src





** We need to learn plugins
*** Rearrange all this
app << smallworld_product.application(:sweo_dm_user)
app.apropos("plugins")
_for i _over app.plugins() # ===== why cant we apropos here?
       _loop
       write(i)
       _endloop

       somePlugin << app.plugin(:maps)

       somePlugin.current_map

==========
       
       print(somePLugin.current_map.current_selection)

       ==========

       print(somePLugin.current_map.current_selection.an_element())

       ==========

       print(somePLugin.current_map.current_selection.an_element().rwo)

       # ========== rwo -> real-world-object
       
** Reading errors
#+begin_quote

Error: Object unset does not understand message close()
# ===== variable doesnt exist

#+end_quote

* How do we delete an item from a collection/list/array/vector?
* Can we do markers? Like read a file and pass the same pointer/marker to another function to continue reading somewhere else 

* Day 4:
** Note the command below
gis_program_manager.databases[:electric].table_for_external_name("Service Point").nth_record(99).usage
** Common beginner mistakes:
*** the field in the GUI is basically the field like a database or a field. So we dont need [:usage] or ("usage"). We just dot (.) like a method. 
*** Basically, like our CSV files on fiverr?

#+begin_src magik
  gis_program_manager.databases[:electric].table_for_external_name("Service Point").nth_record(99).connection_type
  # Again very unusual, connection_type has underscore automatically. But doesnt show in GUI

  gis_program_manager.databases[:electric].table_for_external_name("Service Point").apropos("field")
  # you will get .field()

  # try to search through this iter as a learning experience
  print(gis_program_manager.databases[:electric].table_for_external_name("Service Point").field(:connection_type).type.enumerator.sorted_values)
#+end_src

** A for loop that quits half way. Im sure there are many ways
       _block
       my_i << 1
       _for item _over my_iter4.fast_elements()
       _loop
		write(item)
		_if my_i _is 3
		_then
			_leave
		_endif
		my_i +<< 1
       _endloop
       _endblock
** A simpler one
_block
       _for i _over range(1,3)
       _loop
		write(my_iter4[i])
       _endloop
       _endblock
* Day 5:
** Common beginner mistakes
*** adding _pragma at console. _pragma is only needed in files.
*** Forgetting to remex classes -> remex(:SoMeClAsS)
** Creating classes of cars and makes and models
*** car.magik, ford.magik, honda.magik, accord.magik, prelude.magik, ranger.magik, focus.magik
#+begin_quote

========================= car.magik =========================
_package sw


_pragma(classify_level=basic,topic={test},uage={test})
def_slotted_exemplar(:car,
	{{:price,_unset}},:plugin
)
$

_pragma(classify_level=restricted,topic={help})
_iter _method car.makes()
	##
	## car make method
	##

	_for a_val _over {honda.new(), ford.new()}.fast_elements()
	_loop
		_loopbody(a_val)
	_endloop
_endmethod
$
==================================================


========================= ford.magik =========================
_package sw


_pragma(classify_level=basic,topic={test},uage={test})
def_slotted_exemplar(:ford,
	{{:price,_unset}},:plugin
)
$(delete-region (point) (point-max))

_pragma(classify_level=restricted,topic={help})
_method ford.name
	_return "ford"
_endmethod
$


_pragma(classify_level=restricted,topic={help})
_iter _method ford.models()
	##
	## ford models method, not the s, whatever
	##
	_for a_val _over {focus.new(), ranger.new()}.fast_elements()
	_loop
		_loopbody(a_val)
	_endloop
_endmethod
$
==================================================


========================= ranger.magik =========================
_package sw

_pragma(classify_level=basic,topic={test},uage={test})
def_slotted_exemplar(:ranger,
	{{:price,_unset}},:plugin
)
$


_pragma(classify_level=restricted,topic={help})
_method ranger.name
	_return "ranger"
_endmethod
$
==================================================

#+end_quote





** Read this method
_method map_view.zoom_by(a_factor)
	## Zooms the map view by A_FACTOR.
	   _if .current_view_parameters _isnt _unset
	   _then
	   new_view_def << .current_view_parameters.copy()
	   new_view_def.scale *<< a_factor
	   _self.set_view( new_view_def )
	   _endif
_endmethod


========================= console =========================
myclassreader << _proc @myclassreader(a_folder_path)
       v_classes << {"accord.magik","prelude.magik","focus.magik","ranger.magik","honda.magik","ford.magik","car.magik"}
       _for a_file_name _over v_classes.fast_elements()
       _loop
       	    load_file(a_folder_path + "\" + a_file_name)	
	_endloop
	write("==================================================")
	
	_for each_make _over car.makes()
	_loop
		make << each_make.name
		write("make: ", make)
		_for each_model _over make.models()
		_loop
			model << each_model.name
			write("model: ", model)
		_endloop
	_endloop
_endproc
	
	
	
myclassreader("c:/Users/ahmadardie.r/Documents/my-trash/day5_practice")
==================================================


** Homework:
*** trail geom -> convert to pseudo_area -> .overlap? (service point location)
*** aNSWER
myServicepoint << myMap.current_map.current_selection.an_element().rwo.LOCATION
WILL GET ACTUAL GEOMETRY
note: myMap is from plugin, get the plugin
trail_s_geom << myMap.current_map.trail.as_pseudo_geometry
WILL GET ACTUAL TRAIL AS PSEUDO GEOMETRY
* Day 6
** Errors from the command
*** We can learn to trace the errors (Refer to slide note)
#+begin_src magik
  **** Error: Object unset does not understand message manager
       does_not_understand(object=unset, selector=:manager, arguments=simple_vector:[1-0], iterator?=False, private?=False)

  ---- traceback: Alchemy-REPL (light_thread 1420152204) ----
  time=12/07/2023 10:01:00
  sw!version=5.2.7.0 (swaf)
  os_text_encoding=cp1252
  !snapshot_traceback?!=unset

  condition.raise()            (sys_src/guts/condition.magik:616)
  object.does_not_understand()            (sys_src/guts/object.magik:810)
  object.sys!does_not_understand()            (sys_src/guts/object.magik:684)
  map_view.map_manager            (modules/sw_swaf/map_plugin/source/map_view.magik:2227)
  map_view.calculate_view_for_goto_bounds()            (modules/sw_swaf/map_plugin/source/map_view.magik:2466)
  map_view.goto_bounds()            (modules/sw_swaf/map_plugin/source/map_view.magik:1006)
  map_view.goto()            (modules/sw_swaf/map_plugin/source/map_view.magik:1438)
  <unknown exemplar>.<unknown method>            (Evaluated-inline:1)
  magik_rep.process_command()            (sys_src/misc/magik_rep.magik:136)
  magik_rep.cli()            (sys_src/misc/magik_rep.magik:90)
  system.session_start()            (sys_src/guts/system.magik:3185)
  
#+end_src
**** Basically our map_view.goto() produces the error. But we can trace the error being produced at map_view.map_manager
** Just 2 simple method to compare 2 outputs of different methods from different classes
#+begin_src magik

    # ==================== n1.magik =========================
  remex(:n1)
  $

  _package sw
  $

  _pragma(classify_level=basic, topic={test}, usage={test})
  def_slotted_exemplar(:n1,
	  ## 
	  ## 
	  ## 
	  {},:plugin)
  $

  _pragma(classify_level=basic, topic={test}, usage={test})
  _method n1.out_cost
	  _return "cbvg asdqwd qwd qwd qaq"
  _endmethod
  $

  # ==================================================

  # ==================== n2.magik =========================
  remex(:n2)
  $

  _package sw
  $

  _pragma(classify_level=basic, topic={test}, usage={test})
  def_slotted_exemplar(:n2,
	  ## 
	  ## 
	  ## 
	  {},:plugin)
  $

  _pragma(classify_level=basic, topic={test}, usage={test})
  _method n2.out_cost
	  _return "zsdasd qweqwe "
  _endmethod
  $

  # ==================================================
  # ========================= console =========================
  trace_out_proc << _proc(n1, n2)
			   ## 
			   ## Procedure for sorting the .new_nodes
			   ## priority_queue. 
			   ##
			   # Orders simply on .out_cost.
			   >> n1.out_cost _cf n2.out_cost
  _endproc

  trace_out_proc(n1,n2)
  # ==================================================

#+end_src

** :plugin is needed for cloning an object


#+begin_src magik


  # ========== at console
  def_slotted_exemplar(:person,
		      {{:address, "mentari"},
		       {:number, 01023234}
		      })

  var1 << person.new() # ========== this will produce error

  # we need :plugin to be able to clone this class (what other languages by default simply call it creating an object)


  def_slotted_exemplar(:person,
	  {{:address, "mentari"},
	   {:number, 01023234}
	  },:plugin)


#+end_src


* Day 7
** shared constants and shared variables
#+begin_src magik

  n1.define_shared_constant(
	  :month_names,
	  {"January", "February", "March"},:private
	
    )
  $

  n1.define_shared_variable(:ref_count,0,:public)
  $  

#+end_src

** we access both of these as a method/property (the overpowering . notation). (This is still not naturally for me)
#+begin_src magik
  created_obj.month_names
  created_obj.ref_count
#+end_src

** When we create our own .new method
#+begin_src magik

  _method n1.new()
	  _self.ref_count +<< 1
	  _return _clone
  _endmethod
  $
  # ===== that avoids the problem of having to deal with this error
  # ===== **** Error: Object a n1(unset) sent message init() with too few arguments (requires 2, given 0)
  # so that we can create an object just like this
  new_object << n1.new()


  # If we want arguments
  _method n1.new(_gather args)
	  _self.ref_count +<< 1
	  >> _clone.init(_scatter args)
  _endmethod
  $

#+end_src

** Inheritance: The shape class
*** this is also easier than in other languages, its defined as the last element in the parent bracket, so its out of the way
** Personal Note:
*** I must be suspicious of _self. always. Coz it always confuses me. I must think of the variable name first. The put _self. where needed. 
** An example of creating a shape class, a rectangular class, and then define a mixin. But we have to remex before inheriting that inside our rectangular class. 
#+begin_src magik

  def_slotted_exemplar(:shape,{{:x,_unset,:writable},{:y,_unset,:writable},{:color,_unset,:writable}})
  def_slotted_exemplar(:rectangular,{{:x,_unset,:writable},{:y,_unset,:writable},{:color,_unset,:writable}},:shape)

  # ===== we can redefine freely the slots, since its writable,
  shape.x << 123

  _method my_special_mixin.whatami
	  write("hello there", _self.x)
	  write("Im a ", _self.class_name)
  _endmethod

  remex(:rectangular) ===== need to remex() first
  def_slotted_exemplar(:rectangular,{{:x,_unset,:writable},{:y,_unset,:writable},{:color,_unset,:writable}},{:shape,:my_special_mixin})

	  ========================= we can actually redefine our method inside our class, but we cant redefine our class without remex()

  _method my_special_mixin.whatami
	  write("hello there", shape.x)
	  write("Welcome everyone its me the ", _self.class_name)
  _endmethod

#+end_src


** Reminder:	
*** What if we got something like this

simple_vector(1,4):
1 	1 
2 	simple_vector:[1-4] 
3 	3 
4 	4

===== We can use this

_for key,value _over var1.fast_keys_and_elements()
       _loop
		
		_if value.class_name _is :simple_vector
		_then
			_for item _over value.fast_elements()
			_loop
				write("level 2 : ", item)
			_endloop
			_continue
		_endif
		write(value)
	_endloop

========================= output =========================
1
level 2 : spiderman
level 2 : is
level 2 : a
level 2 : pussy
3
4

** Hey we did it!! a procedure adding an element from 2 ropes into a multi-rope. No errors so far. Inspired my Common lisps datatype list. Where they can pop elements.
#+begin_src magik

  feedMe << _proc @feedMe(rope1, rope2)
		    # compare the sizes first
		    # whichevers bigger make it the size of final rope
		    _if rope1.size < rope2.size
		    _then
			    m_size << rope2.size
		    _else
			    m_size << rope2.size
		    _endif

		    # a rope of ropes
		    full_rope << rope.new_for(2)
		    full_rope[1] << rope.new_with()
		    full_rope[2] << rope.new_with()

		    _for mycount _over range(1,m_size)
		    _loop @outer
			    _if rope1.empty? _orif rope2.empty?
			    _then
				    _leave @outer
			    _else
				    full_rope[1].add(rope1[1])
				    full_rope[2].add(rope1[1])
				    rope1.remove_nth(1)
				    rope2.remove_nth(1)
				    write("were removing rope1 at ", mycount)
			    _endif
		    _endloop		 		  
	 _endproc

  # ==================================================
  var1 << rope.new_with(1,2,3); var2 << rope.new_with(4,5,6,7)
  # ==================================================
  feedme(var1,var2) ===== IT WORKS!!

#+end_src

* Day 8
** datatypes with keys and values
*** rope, hash table, equality property list, property list
*** hash table uses symbols as keys, equality property list uses strings, property list uses symbols
*** equality set, also a dataytype, will not include duplicates
*** equality bag, VERY interesting, does not have duplicates, but stores occurences of duplicates upon creation
*** sorted collection has sorting. but rope HAS a sorted method
*** sorting with our own method
#+begin_src magik
  
  rope1 << =========================

  dec << _proc(a,b)
		 >> b _cf a
	 _endproc

  print(rope1.as_sorted_collection(dec))

#+end_src


** Personal
*** Lets create a "get" method that returns when list matches a pattern
*** This is probably a useless exercise since even fields are objects. And strings are important datatype in magik. So we need a different workout
*** 
** Random note:
*** When implemented, whats the difference between a field and a slot ??     (:someSlot)
*** If you try init() <--------> new() exercise. You'll quicky realize . notation even more ambiguous (whats the different between shared variables and a slot??)
*** Here's some interesting discovery. Also the init() <--------> new() exercise. passing arguments from .new() to .init() is just a convention. You can also pass .new2 to .init(). The result is the same. 
*** [[file:~/Documents/my-trash/magik_practice/2023-07-14_at_15hours/pop_numbers_at_2.magik][example of .new2 instead of .new we may decide to just delete and copy code here]]
*** ==========
* Day 9 
** hash_table automatically remove duplicates when created (new_with)
** property_list on the other hand allows duplicates
#+begin_src magik
  my_hash << hash_table.new_with({:abc, "abc", :def, "def", :abc, "another one"})
  # the 2nd abc will not be shown
#+end_src
** integers and symbols are same objects (Eg: 1 and 1, :abc and :abc). Strings and float are different objects (Eg: 1.3 _is 1.3 and "asd" _is "asd" will return false)
** set views integers and symbols as "object strict". So objects are not duplicated. Example:
#+begin_src magik

  set1 << set.new_with(1,2,3,123,1,2,3,:asd,:asd)
  print(set1)
  # ========== output ==========
  # 1
  # 2
  # 3
  # 123
  # :asd

#+end_src

** set treats everything like real objects. So, it makes it will have methods like .union(), .intersection(), .difference()
#+begin_src magik

  set1 << set.new_with(1,2,3,4,5,6)
  sw:set(6) 
  Magik> set2 << set.new_with(5,6,7,8)
  sw:set(4) 
  Magik> print(set1.difference(set2))
  # ========== output ==========
  # set:
  # 1 
  # 2 
  # 3 
  # 4 
  # ----- The way to think of the .difference() method, is that it operates ON the first set


#+end_src

** An rwo set example
#+begin_src magik

  _block
	  _local r_set << rwo_set.new()
	  _local sp1 << gis_program_manager.databases[:electric].collections[:eo_service_point]
	  _for a_rwo _over sp1.fast_elements()
	  _loop
		  r_set.add(a_rwo)
	  _endloop
	  write("the size", r_set.size)
	  print(r_set)
	  r_set.add("asd") # only this line will produce error
  _endblock

#+end_src

** Geometry set

#+begin_src magik

  _block
	  _local g_set << geometry_set.new()
	  _local sp1 << gis_program_manager.databases[:electric].collections[:eo_service_point]
	  _for a_rwo _over sp1.fast_elements()
	  _loop
		  g_set.add(a_rwo.location)
	  _endloop
	  write("the size", g_set.size)
	  print(g_set)

  _endblock

#+end_src





==================================================
We must try the conditions. theres also different types like not just :error, but also :warning & :information. TRY IT
==================================================

file_logger << _proc @file_logger(input_file_name, output_file_name)

                    in_stream << external_text_input_stream.new(input_file_name)
		    log_stream << external_text_output_stream.new(output_file_name)

		    

                    _protect
                        _loop@outer
                            a_line << in_stream.get_line()

                            _if a_line _is _unset _then  _leave _endif

                            log_stream.write(a_line)
			    log_stream.write(%newline)
			    

                        _endloop
                    _protection
                        in_stream.close()
			log_stream.close()
                    _endprotect

                _endproc

file_logger("some_path_to_input_file","some_path_to_output_file")



		
* Day 10
** binary formats
** No interesting examples shown. But we rarely use anyway.

#+begin_src magik

  # ========== we can try this with a raw PDF, it will work
  _proc@test (input_file_name, output_file_name)
	  in_stream = external_binary_input_stream(input_file_name)
	  log_stream = external_binary_input_stream(output_file_name)
	  _protect
		  file1 << file_status.new(input_file_name)
		  bv << byte_vector.new(file1.size)
		  in_stream.get_vector(bv)
		  log_stream.put_vector(bv)

	  _protection
		  write("closing files")
		  in_stream.close()
		  log_stream.close()
	  _endprotect
  _endproc

#+end_src
** witness _protect, _protection & _endprotect in action

my_catch << _proc@ my_catch(fname)
       _catch :file_error
       	      _handling error _with
	      _proc(cond)
			_throw :file_error
		_endproc
		a_file << external_text_output_stream.new(fname)
	_endcatch
	write("your bloody file is ", a_file)	
	_if a_file _is _unset
	_then
		condition.raise(:user_error, :string, "unable to wreite to this file" + fname)

					     _endif
_endproc
** It works even in simple situations
_block
		_protect
			"some text".stupid_nonexistent_function()
		_protection
			write("==================================================")
			write("the function stupid_nonexistent_function doesnt exist")
		_endprotect
_endblock
** But commonly used like the following (note the additional use of a flag, which means we combine it with another conditional to make it safe to commit some changes aka file/database/etc changes)
#+begin_src magik

  # Setup a flag
  ok? << _false
  _protect
	  <write some data to the database>
		  # We made it through the ify code. Set flag to true.
		  ok? << _true
  _protection
	  _if ok?
	  _then
		  <commit the database>
	  _else
		  <rollback the database>
	  _endif
  _endprotect

#+end_src
*** Also note that we can use question marks in variables in Magik. Like --> whateverVariable? 
** 
** PLease rearrage this better

#+begin_src magik

  condition.define_condition(:my_error_condition, :error, {:age,:address}, "hello I am #1 years old, and I live in #2")

  # note the usage: using numbers like #1 makes it different from your average function. Error catching functions are special after all. Makes a one-liner easier too

  # to test whether a condition you can use this
  # condition.condition_exists?(:warning)

  condition.raise(:my_error_condition,:age,32,:address,"mentari")

  ========== from method definition: ==========
  method define_condition(name,parent_name,data_name_list, optional reporter,message_accessor) 

#+end_src


* Day 11
** product.def
** Compiling messages

#+begin_src magik
  
  sw_module_manager.apropos("compile_mess")

  # would have to delete msgc to see this in action

  sw_module_manager.compile_messages(:eo_phase_conventions)

#+end_src
** try and catch errors are meant to redirect error flows from its usual flow
** try and catch error

#+begin_src magik

  _try _with cond
  write("Hello")
  write("HELLOOOOOO")
  "asd".enter
  write("nothinnnnnnnngg")
  _when error
	  write(cond.report_contents_string)
  _endtry


  # Like other programming languages, theres an implied variable, that will automatically catch the error. IN the example, its "cond"
  # The variable "cond" is also local

#+end_src
** another catch and try

greet1 << _proc()
       	      _catch @my_tag
       	      write("Hello")
	      greet2()
	      write("Hello again")
	      _endcatch
	      _endproc


	      greet2 << _proc()
       	      write("How are you")
	      "somenonexistent".enter
	      _throw @my_tag
	      _endproc
** Some advanced example (with _proc inside another _proc, and _throw, and _catch, and ). The real question is, why would we want to use this one?
#+begin_src magik

  proc_handle << _proc @proc_handle()
			 _catch :carry_on
				_handling file_does_not_exist _with 
				_proc(cnd)
					write("Catched and processing the error..")
					#cnd.report_on(!output!)
					#!traceback!(!output!)
					_throw :carry_on
				_endproc

				_protect
					condition.raise(:file_does_not_exist,:filename, "abc")
				_protection
					write("<<Error handled..>>") 
				_endprotect
			 _endcatch 
	      _endproc


#+end_src


* Day 12
** =====

#+begin_src magik

  _try
	  _with cond
	  # ===== you can also put _with on a new line
	  condition.raise(:warning,:var1,"some text")

  _when error
	  write("im handling other errors")
	  write(cond.report_contents_string)
  _when warning
	  write("default variables used")
	  write(cond.report_contents_string)
  _endtry



#+end_src
** Food for thought -> 
** Perhaps, perhaps another advantage separating init() from new(), is that we have more flexibility, so we can have a "data filller" function that ends with "data loaded but we skipped the 2nd variable". Example:


#+begin_src magik
  
  def_slotted_exemplar(:my_class,
		      ## 
		      ## 
		      ## 
		      {{:one, 1},{:two, 2}})


  _method my_class.new(var1,var2,var3)
	  >> _clone.init(var1,var2,var3)
  _endmethod


  _private _method my_class.init(var1,var2,var3)
	  .one << var1
	  .two << var3
	  write("data loaded, but we are skipping var2")
	  _return _self
	  # _return _self -----> is only for classes that load :plugins
  _endmethod


#+end_src

** Write about chevron methods. That overload << thingy

*** Say we have a class called i_am_cool

_pragma(classify_level=basic, topic={i_am_cool}, usage={test})
_method i_am_cool.new_value << chev_value
	## 
	## 
	.one << chev_value
	.two << chev_value
	.three << chev_value
_endmethod
$

test << index_and_chevron.new("Marry", "Louis","Rockey")
Global test does not exist: create it? (Y) 

test[:one]
"Marry" 

test.new_value << "Aravindh"
"Aravindh" 

test[:one]


** iter methods remind me of  mapcar in Common Lisp. Its one way to think of it. Basically, "map each of these values to our function here" or "do this n times on our function here"


def_slotted_exemplar(:test_iter, {})


 _iter _method 
test_iter.iter_method(total)
_for i _over range(1,total)
_loop
_loopbody(i)
_endloop
_endmethod

 _for i _over 
test_iter.iter_method(5)
_loop
show(i)
_endloop

1
2
3
4
5

 animals <<_iter _proc()
_loopbody(:cow)
_loopbody(:cat)
_loopbody(:rat)
_loopbody(:tiger)
_endproc


 _for i _over animals()
_loop
show(i)
_endloop


:cow
:cat 
:rat 
:tiger


* Day 13
** Advanced collection classes
** equality_set is "less strict in how it respects its object" or "less strict in what it considers an object" (it doesnt need to have the same addess to be considered the same "object")
#+begin_src magik

  my_s << set.new_with("abc","abc")
  # ===== sw:set(2)

  my_eqs << equality_set.new_with("abc","abc")
  # ===== sw:set(1)

#+end_src


** An interesting and useful function to test for this is .includes?()

#+begin_src magik
  
  my_s.includes?("abc")
  # ===== False

  my_eqs.includes?("abc")
  # ===== True

#+end_src



** Identity is basically the default consideration in magik

#+begin_src magik

  b << bag.new_with(1,2,1,2,5,2.5,2.5,"rpc","rpc")
  print(b)
  ## bag:
  # 2 1 
  # 2 2 
  # 1 5
  # 1 2.5
  # 1 2.5 
  # 1 "rpc" 
  # 1 "rpc" 

#+end_src

** Stack
*** you know this one. very cool as usual
** sorted_c
*** when we create a new sorted_collection. Always need a procedure. Or if build in pocedure, needs first number  (although not expected)
#+begin_src magik

  sort2 << sorted_collection.new(9, :strings_with_numbers)

  # ==========

  dec << _proc(a,b)
		 >> a _cf b
	 _endproc


  proper_sort << sorted_collection.new(8,dec)

  # ===== we always need a first number

#+end_src


** weak set
#+begin_src magik

  myrope << rope.new_with(9,7,9,6)

  myref << weak_reference.on(myrope)

  myrope.remove_nth(1)

  print(myref.referent)

  # rope(1,3):
  # 1 	7 
  # 2 	9 
  # 3 	6


#+end_src


** A cool but difficult trick in Magik that reminds me of Common Lisp mapcar
*** We should explore this
#+begin_src magik

  "25,55,55".split_by(%,). map(_proc(a) >> (a.as_number()/255.0) * 100 _endproc)

#+end_src

* Day 15
** try catch and throw (with maybe handling) is very confusing. I STILL dont get it. 
** But I did manage to get this

#+begin_src magik

  sometest << _proc @sometest()
		      _try
			      _with cond
			      condition.raise(:my_error,:location,"sometest")
		      _when my_error
			      write("my_error occured")
			      cond.report_on(!error_output!)
		      _endtry
	   _endproc


#+end_src

* Day 16

** Should write about this one. And really test this. Uses databus and highlight plugin

_block
    app << smallworld_product.applications.an_element()

 

    vw << gis_program_manager.databases[:electric]

 

    scanner << vw.geometry_scanner(:general)

 

    # get the bounding box defined by the trail
    bd << app.databus.request_data(:map_trail)[2].bounds

    # start the scanner with the bounds
    scanner.start_scan(bd)

 

    # now define a loop to retrieve all the geometry
    _loop 
          geom << scanner.get()

          # test for end of geometry 
           _if geom _is _unset _then _leave _endif

 

           # Write the scanned objects on the magik prompt
           write("+++ Scanned Objects +++",geom.rwo)

 

           # code here to process the geometry - for example 
           _if geom.rwo.rwo_type _is :eo_service_point
           _then
            app.databus.make_data_available(:geometry_to_highlight, geom)
           _endif
    _endloop
_endblock


* Day 17
** I dont understand threading. Actually, I understand a bit, but the engine concept and dependent seems unrelated. Its just an example. Dont get confused.

#+begin_src magik
  def_slotted_exemplar(:my_engine,

		      {{:slot1, _unset
		       }},:engine_model)

  # ==========

  _method my_engine.new()
	  ## 
	  ## 
	  >> _clone.init()
  _endmethod


  # ==========

  _method my_engine.init()
	  ## 
	  ## 
	  _super.init()
	  >> _self
  _endmethod

  # ==========

  _method my_engine.call()
	  _self.run_engine(_thisthread.background_priority, 
			   :sillycall|()|) 
  _endmethod

  # ==========

  _method my_engine.sillycall()
	  ## 
	  ## 
	  _self.changed(:engine_started)
	  _for i_cnt _over 1.upto(5)
	  _loop
		  _self.changed(:engine_running)
		  _thisthread.sleep(1000)
	  _endloop
	  _self.changed(:engine_stopped)
  _endmethod


  # ==========
  def_slotted_exemplar(:my_plugin,
	  {{:engine, _unset}},:plugin)

  # ==========

  _method my_plugin.new()
	  ## 
	  ## 
	  >> _clone.init()
  _endmethod

  # ==========

  _method my_plugin.init()
	  .engine << my_engine.new()

	  .engine.add_dependent(_self)
	  >> _self
  _endmethod

  # ==========

  _method my_plugin.call_engine()
	  .engine.call()
  _endmethod

  # ==========

  _method my_plugin.note_change( who, 
				 what, data )
	  ## 
	  ## 
	  _if what _is :engine_started
	  _then
		  write("!! Engine started !!, notification received from engine")
	  _elif what _is :engine_running
	  _then 
		  write("!! Engine running !!, notification received from engine")
	  _elif what _is :engine_stopped
	  _then
		  write("!! Engine stopped !!, notification received from engine")
	  _endif 
  _endmethod


  # ==========
#+end_src





** Holy fuck Im a genius. I discovered a cool trick. Well, kind of. Not sure how common, useful or easy-for-others (which is also the point, if its too weird, then its useless). Write this one down properly. I dont know. Maybe its just funny.

#+begin_src magik

  # ==========
  roper << _proc @roper(rope1,element1)
		   rope1.add(element1)
	_endproc
  # ==========

  _global addtorope << _proc @addtorope(inrope)
			       >> _proc @message(inelement)
					  _import inrope
					  write("feeding element", inelement, "into rope")
					  print(inrope)
					  >> roper(inrope,inelement)
				  _endproc	      
		       _endproc

  # ==========
  rope_test << rope.new_with()
  # ==========
  addperson << addtorope(rope_test)
  # ==========
  addperson(2)
  # ==========
  addperson(3)

  # ========== output ==========
  # Magik> print(rope_test)
  # rope(1,2):
  # 1 	2 
  # 2 	3

#+end_src

** Examples of my own question


#+begin_src

Question 1:
if its a helper function then we can clearly create multiple constants. That would save a TON of time. lets say it accepts 2 ropes as inputs. and the textual function itself adds whatever element we have into those 2 functions.


This is kinda useless, but who cares.


Question 2:
another function that accepts 2 ropes at first, to establish that functino. Then we create a textual function that display when we pass an argument to it, in which rope ists, in which it doesnt of the 2 ropes.

scratch that. We now use equality_set instead of rope.
  
#+end_src



#+begin_src magik

  _global mydualsearch << _proc @mydualsearch(eset1,eset2)
				  write("creating a meta function")
				  >> _proc @mysearch(element)
					     _import eset1
					     _import eset2
					     write("searching eset1 and eset2")
					     _if eset1.includes?(element)	    
					     _then
						     write("the first set has it!")
					     _else
						     write("set 1 doesnt have it, adding....")
						     eset1.add(element)
					     _endif
					     _if eset2.includes?(element)
					     _then
						     write("the second set has it")
					     _else
						     write("set 2 doesnt have it, adding it...")
						     eset2.add(element)
					     _endif
				     _endproc
		       _endproc

#+end_src



* Day 18
** Post mortem
*** New version behaves different. you need to generate a .jar file from module, before you can garbage collect (I think so.....)
** A way to test private function, without going through the whole process of creating an object

#+begin_src magik

    remex(:test_sys)
  $


  _pragma(classify_level=basic, topic={test}, usage={test})
  def_slotted_exemplar(:test_sys,
	  ## 
	  ## whatever
	  ## 
	  {{:first,unset}},:plugin)
  $


  # Why is it so easy to forget that _clone part?? There is
  # another way to do it, but I keep forgetting this method
  _pragma(classify_level=basic, topic={test}, usage={test})
  _method test_sys.new()
	  ## 
	  ## 

	  >> _clone.init()
  _endmethod
  $

  _pragma(classify_level=basic, topic={test}, usage={test})
  _method test_sys.init()
	  ## 
	  ##

	  .first << "haha"
	  >> _self 

  _endmethod
  $




  _private _method test_sys.useless() 
	  # Yields a NUMBER of random integers from 0 to RANGE - 1 

	  write("hello there")

  _endmethod
  $


  # ====================

  wow << test_sys.new()

  # ====================

  wow.sys!perform(:useless|()|)

  # ====================

#+end_src

* My examples (special variable _import and functional language)

** First we can actually feed a method into another method. Crazy!!

#+begin_src magik

  in_method << _proc @in_method(somestring)
		       write(somestring)
	    _endproc

  out_method << _proc @out_method(somefunc,astring)
			somefunc(astring)
		_endproc

  # Magik> out_method(in_method,"hello there")


#+end_src

** The first is using our variable of interest. So we simplify function. Example: simplifying add_to_rope(rope1, "asd") to add_to_rope1("asd")
#+begin_src magik

    # ==========
  roper << _proc @roper(rope1,element1)
		   rope1.add(element1)
	_endproc
  # ==========

  _global addtorope << _proc @addtorope(inrope)
			       >> _proc @message(inelement)
					  _import inrope
					  write("feeding element", inelement, "into rope")
					  print(inrope)
					  >> roper(inrope,inelement)
				  _endproc	      
		       _endproc

  # ==========
  rope_test << rope.new_with()
  # ==========
  addperson << addtorope(rope_test)
  # ==========
  addperson(2)
  # ==========
  addperson(3)

  # ========== output ==========
  # Magik> print(rope_test)
  # rope(1,2):
  # 1 	2 
  # 2 	3
  
#+end_src
** The second is feeding a function as a argument.


#+begin_src magik

  internal_writer << _proc @internal_writer(item)
				  write(item)
			  _endproc


  _global external_method << _proc @external_method (somefunc)
					  >> _proc @internal (mystring)
						   _import somefunc
						     somefunc(mystring)
					     _endproc
				  _endproc



  # Magik> test_writer << external_method(internal_writer)

  # Magik> test_writer("hello there")


#+end_src

* Day 19
** Application architecture
*** ========== Mostly a reminder of what we did in the past. But I still cant fully grasp strangely

smallworld_product.application(:sweo_dm_user).plugin(:maps).current_map.current_selection

*** The actual location of the .db itsewlf (.jou generates when we use an app accessing it)
**** E:\SmallWorld\electric_office\example_db\ds\ds_electric
*** We need to read about SOC (Spatial Object Controller), how it manages many data sources (from files to databasesa)
** Getting the databus datatypes
write(""); write(""); smallworld_product.application(:sweo_dm_user).databus_consumer_data_types[2]
** Try selecting several types of object in the map. and get the selection like this
smallworld_product.application(:sweo_dm_user).plugin(:maps).current_map.current_selection
** Exercises
*** Through the editor manager plugin we can get the current selected object
*** Select multiple objects in map manager. show the result in the explorer window
** Lists coz we have no clue what we're doing

#+begin_src magik


  smallworld_product.application(:sweo_dm_user).databus_consumer_data_types[2]
  smallworld_product.application(:sweo_dm_user).plugin(:maps).current_map.current_selection
  smallworld_product.application(:sweo_dm_user).plugin(:editor_manager)

  # from Syed
  _block
	  swapp << smallworld_product.application(:sweo_dm_user)
	  #print(swapp)
	  #print_ancestry(smallworld_product)
	  #swapp.report_plugins()
	  print(swapp.plugin(:maps).current_map.current_selection.rwo_set())
  _endblock
  
#+end_src

** 

* Day 20
** Only the first layer is raster image. Above that we can have state info, district info, operation layer. ACE can configure what users can see and cannot see
** Version management (TNB)
*** CPP
**** design work
**** electric
*** SNC
**** GIS
**** electric
*** Asset registration
**** land
**** design work
** Exercise (This is a lot to take in). This one is to merely tp teach predicates. But note the many details here
#+begin_src magik

  _block
	       _local gis_db << gis_program_manager.databases[:electric]
	       _local sw_eoapp << smallworld_product.application(:sweo_dm_user)
	       _local sw_eoapp_plmaptrail << sw_eoapp.plugin(:map_trail)
	       _local pseudo_geom << sw_eoapp_plmaptrail.current_trail.as_pseudo_geometry

	       _local pred1 << predicate.interacts(:location,pseudo_geom)
	       _local pred_coll << gis_db.collections[:eo_service_point].select(pred1)

	       _for item _over pred_coll.fast_elements()
	       _loop
		       write(item)
	       _endloop
       _endblock
  
#+end_src
** The same thing, but this time for cable_segment. We cant the geometry type (this time its :route) from the editor pane in the app.

#+begin_src magik

  _block
	       _local gis_db << gis_program_manager.databases[:electric]
	       _local sw_eoapp << smallworld_product.application(:sweo_dm_user)
	       _local sw_eoapp_plmaptrail << sw_eoapp.plugin(:map_trail)
	       _local pseudo_geom << sw_eoapp_plmaptrail.current_trail.as_pseudo_geometry

	       _local pred1 << predicate.interacts(:location,pseudo_geom)
	       _local pred_coll << gis_db.collections[:eo_cable_segment].select(pred1)

	       _for item _over pred_coll.fast_elements()
	       _loop
		       write(item)
	       _endloop
       _endblock
  
#+end_src
** We can list all state/city areas using
#+begin_src magik

  _for item  _over gis_db.table_for_external_name("Layout Area").fast_elements()
       _loop
	       write(item.name)
       _endloop
       
#+end_src
** You can also get the above from zoomin out in the app. And look for Layout Area in the object collection drop-down.
#+begin_src magik

  _block
	  _local gis_db << gis_program_manager.databases[:electric]
	  _local sw_eoapp << smallworld_product.application(:sweo_dm_user)
	  _local layout_area_coll << gis_db.collections[:layout_area]
	  _local pseudo_geom << layout_area_coll.at(1220618).area
	  # _local sw_eoapp_plmaptrail << sw_eoapp.plugin(:map_trail)
	  # _local pseudo_geom << sw_eoapp_plmaptrail.current_trail.as_pseudo_geometry

	  _local pred1 << predicate.interacts(:location,pseudo_geom)
	  _local pred_coll << gis_db.collections[:eo_service_point].select(pred1)

	  _for item _over pred_coll.fast_elements()
	  _loop
		  write(item)
	  _endloop

  _endblock

#+end_src

** Some notes
*** the layout_area_coll.at(1220618) looks like this in apropos. method at( gather keys_list) in dd_collection_mixin
*** 
** Rearrange later

#+begin_src magik

  _block
           _local ds << gis_program_manager.databases[:electric]
           #_local app << smallworld_product.application(:sweo_dm_user)
           _local layout_area_coll << ds.collections[:layout_area]
           _local ps_area << layout_area_coll.at(1220625).area

           a_scanner << ds.scanner_for({:sw_gis!area, :sw_gis!chain, :sw_gis!point}, ds.world)

 

           _for a_geom _over a_scanner.elements_within_coord_box(ps_area.bounds) 
        _loop
            write(a_geom.rwo)
        _endloop

_endblock

#+end_src


* Day 21
** A service point is a heterogenuous collection of data points. (??)
**

#+begin_src magik

  sw_app << smallworld_product.applications.an_element()

  an_rwo << sw_app.database.rwo_set()

  a_coll << an_rwo.select(:collection,{:eo_service_point})

  a_coll.size

  a_coll.an_element().transformer

  print(a_coll.an_element())

  
#+end_src
** Note that the transfomer is a single join (note the icon). And the sevice connection is a multi join (note the icon & also the select_collection(eo_service_connection), others like circuit_section show a db_set, basically a collection of records).
** Note the icons in the GUI. And here are the fields
*** physical field
*** enumerated field
*** join field
*** logical field
*** intergration field
*** catalogue field
** Basically below gets a record. Note the id inside ()
#+begin_src magik

    _for a_rec _over a_coll.an_element().circuit_and_section.fast_elements() _loop write(a_rec) _endloop

  # so we can the record intself

    gis_program_manager.databases[:electric].collections[:eo_circuit].at(314122)

#+end_src
** Reverse searching as practice
#+begin_src magik

    gis_program_manager.databases[:electric].collections[:eo_service_point].an_element().location

  # this will get the geometry information

  # if were to reverse search the record (object) itself from geometry infromation we do this

  gis_program_manager.databases[:electric].collections[:sw_gis!point].at({353475442,1057561421,888922}).rwo

  # note the symbol which allows us to :sw_gis!point to get all points data, so collections[:] has some interesting search capability?

#+end_src


** We do the same for cable segments. Keywords: cable segment, route, chain
**

#+begin_src magik

  _for i _over gis_program_manager.databases[:electric].collections.fast_keys()
  _loop
	  write(i)
  _endloop
  # this, we get eo_cable_segment_inst

  gis_program_manager.databases[:electric].collections[:eo_cable_segment_inst].an_element().route
  # we get chain:(gis_id(352321536,0,4687))


  gis_program_manager.databases[:electric].collections[:sw_gis!chain].at({352321536,0,4687}).rwo`




#+end_src

** (Later need to test this theory). Instead of collections[:], we can use select() with an rwo & combine with predicate to make it more flexible

#+begin_src magik


  an_rwo << sw_app.database.rwo_set()
  
  an_rwo.select(predicate.like(:status, "Existing"))  # can check .size

  # can use some weird almost Regex like thing. Coz like() is flexible


  an_rwo.select(predicate.like(:status, "%xistin%"))
  an_rwo.select(predicate.like(:status, "%xistin%")).size
 # the same size as results before


#+end_src

** By field types!! So it will display several records

#+begin_src magik

  print(an_rwo.select(:field,{:route}))

  print(an_rwo.select(:field,{:area}))

#+end_src

** For geomertry sets, a new app

#+begin_src magik


  geom_set << sw_app.geometry_set_factory()

  geom_set.get_geometry_set_for(:|EO|,gis_program_manager.databases[:electric].world)



#+end_src

** There are many others of interest
*** get_application_world(universe_name_id, world_name_id)
*** you can get information on world from

print(gis_program_manager.databases[:electric].world)
*** and




print(gis_program_manager.databases[:electric].world.universe)


app_world << geom_set.get_application_world_for_world(gis_program_manager.databases[:electric].world)


app_world.worlds
# this will show 8 internal worlds, for the 4 dataset that have an external and internal world



print(geom_set.get_display_styles_for(:|EO|))
# View -> View Properties -> Display Style (dropdown)
** There are many ways to extract the same set of information in Magik. Note that these 2 evaluate to True when we use _is
*** gis_program_manager.databases[:electric].rwo_set().select(:collection,{:eo_cable_segment_inst})
*** sw_app.database.rwo_set().select(:collection,{:eo_cable_segment_inst})

* Day 22
** We are creating a new project. The process always goes
*** zoom in onto a desired object. To restrict our project. IN our case we used service point (get and goto)
*** We create a new design
*** we change state to "as built changes"
*** 
** Inserting a record. and the changes reflected automatically in our GUI app. Example:
#+begin_src magik

  _block
	       _local ds << gis_program_manager.databases[:electric]
	       _local a_coll << ds.collections[:eo_service_point]
	       _local our_app << smallworld_product.application(:sweo_dm_user)
	       !current_application! << our_app
	       _local a_map_trail << our_app.plugin(:map_trail).current_trail
	       _local l_point << a_map_trail.as_pseudo_geometry  
	       _local l_prop << property_list.new_with(:status,"Existing",
							:network_type,"LV",
							:phasing,"A",
							:owner_type, "Company Owned",
							:owner_name,"GE West",
							:remarks,"a new insert from Ardie",
							:location, l_point)
		mytransaction << record_transaction.new_insert(a_coll, l_prop, "some comment")
		mytransaction.run()

       _endblock

#+end_src
** We are cloning a record. But make sure we give a location, coz searching that is possible. but our GUI cant locate it to show it
** Now, we are updating a record

#+begin_src magik

  _block
	       _local ds << gis_program_manager.databases[:electric]
	       _local a_coll << ds.collections[:eo_service_point]
	       _local our_app << smallworld_product.application(:sweo_dm_user)
	       !current_application! << our_app
	       _local a_map_trail << our_app.plugin(:map_trail).current_trail
	       _local l_point << a_map_trail.as_pseudo_geometry  
	       _local l_prop << property_list.new_with(:remarks,"ardies update successful",
							:network_type, "MV",
							:phasing,"ABC")

		mytransaction << record_transaction.new_update(a_coll.an_element(), l_prop, "some comment")
		mytransaction.run()
		
       _endblock

#+end_src
** How do we delete our selection??
#+begin_src magik

  _block
	       _local ds << gis_program_manager.databases[:electric]
	       _local a_coll << ds.collections[:eo_service_point]
	       _local our_app << smallworld_product.application(:sweo_dm_user)
	       !current_application! << our_app
	       _local a_map_trail << our_app.plugin(:map_trail).current_trail
	       _local l_point << a_map_trail.as_pseudo_geometry  
	       _local l_prop << property_list.new_with(:remarks,"ardies update successful",
							:network_type, "MV",
							:phasing,"ABC")



		mytransaction << record_transaction.new_delete( smallworld_product.application(:sweo_dm_user).plugin(:maps).current_map.current_selection.an_element().rwo, "some comment")
		mytransaction.run()

       _endblock
  
#+end_src
** Dataset transaction.
** First we select 3 and get thir ID.

#+begin_src magik

      smallworld_product.application(:sweo_dm_user).plugin(:maps).current_map.current_selection.an_element().rwo

      # note how an_element() needs to be used like previous Eg. Apparently, an_element(). is more than just "getting the first record".

       _for i _over smallworld_product.application(:sweo_dm_user).plugin(:maps).current_map.current_selection.fast_elements()
    _loop
	    write(i.rwo)
    _endloop

  #   eo_service_point28219:(648435)
  # eo_service_point28219:(648437)
  # eo_service_point28219:(648436)


    _block
	       _local ds << gis_program_manager.databases[:electric]
	       _local a_coll << ds.collections[:eo_service_point]
	       _local our_app << smallworld_product.application(:sweo_dm_user)
	       !current_application! << our_app
	       _local a_map_trail << our_app.plugin(:map_trail).current_trail
	       _local l_point << a_map_trail.as_pseudo_geometry  
	       _local l_prop << property_list.new_with(:remarks,"ardies update successful",
							:network_type, "MV",
							:phasing,"ABC")

		trans_rope << rope.new_with()					
		_for i  _over {648436,648437,648435}.fast_elements()
		_loop
			rt << record_transaction.new_delete(a_coll.at(i),"delete")
			trans_rope.add(rt)
		_endloop

		dt << dataset_transaction.new(trans_rope,"delete")

		dt.run()

       _endblock



#+end_src

** 

* Day 23
** Im lagging now
** If you want to really understand, regarding the physical_fields, and Geom_fields, and other types of fields

#+begin_src magik


  rwos << prof_app.database.rwo_set()

  rwos.source_descriptors()

  rwos.source_field_descriptors()

  

#+end_src
** WHat exactly is describe_trigger?

#+begin_src magik

  rwos.select(:collection,{:eo_service_point}).an_element().describe_triggers()

  
#+end_src
** PLEASE!! Try and complete this one out later
#+begin_src magik

  _block
sw_app
pl_map
a_map_view << pl-map.current.new_view()
a_map_view.set_view(pl_map.current_map_view.current_view_parameters())
f << frame.new("RPS training test canvas")
c << canvas.new(f,400,400)
f.activate()
a_map_view.set_rendering_surface(c)
a_map_view.render()
_endblock
  
#+end_src
** Pretty cool. This will definitely work

#+begin_src magik

  _block
app << smallworld_product.applications.an_element()
mapman << app.plugin(:maps)
a_map_view << mapman.current_map.new_view()
a_map_view.set_view(mapman.current_map_view.current_view_parameters() )
docman << app.plugin(:document_manager)
mgf << map_gui_framework.new( :test, app, :map_manager, mapman, 
:document_manager, docman, :resource_module_name, :map_plugin,
:floating_gui_definition_file_name, "floating_map_gui.xml",
:embedded_gui_definition_file_name, "embedded_map_gui.xml" )
mgf.activate(_unset, "RPC TEST MAP FRAMEWORK")
mgf.document << a_map_view
a_map_view.render()
_endblock

#+end_src
** Next class, we can create simple GUI window/frame by inheriting :model (more simple). We can configure actions too. 
** NOTE-TO-SELF:

#+begin_src magik

    !print_float_precision! << 10

    # ========== to increase precision point, so that, we can have our coordinates properly, to feed into ---> 
    # our_app.plugin(:map_trail).current_trail.add_geom(se)

#+end_src

* Day 24
** GUI Frameworek --> customize framework --> activation plugin --> GUI plugin --> model/engine model
** How a plugin (producer) pushes data into a databus. NOTE: the following example will NOT work. even if you replace _self correctly. 

#+begin_src magik

  _self.databus.make_data_available(:set_map_selection,
				   {cur_map, geom_set})

  # :set_map_selection is a data_type_name

  _method selection_reporter_plugin.sw_databus_data_available( data_type_name,
							       data )
	  _if data_type_name _is :map_trail
	  _then
		  (a_map, a_trail) << ( _scatter data )
		  .map_trail << a_trail
	  _endif
  _endmethod

  

#+end_src

** Applied example

#+begin_src magik

  _block
	  _local app << smallworld_product.applications.an_element()
	  _local po_set << rope.new_with()
	  _for a_set _over app.sys!perform_iter(:databus_request_all_data|()|, :map_selection)
	  _loop
		  po_set.add(a_set)
	  _endloop
	  print(po_set[1])
  _endblock

#+end_src
** Creating action objects

#+begin_src magik

  sw_action.new( :clear,
	       :image, { :clear, :ui_resources },
	       :engine, _self,
	       :action_message, { :current_object|<<|, _unset } )

  # you either mention the :clear in message files along with
  # filenames. OR you can mention file by filename.



#+end_src

** Process on how to see electric trace, and see cable segments connecting it
*** As usual, in your editor, get the first instance of a service point object. Make sure to select it
*** click Electric Trace. Switch direction to Upstream, since this is a Service Point. 
*** Click Go To in that floating Window itselc
*** Click to Explorer. CLick Network Analysis, to see all cable segments connecting it.
* Day 25
** Today we are loading using a module manager
#+begin_src magik



  sw_module_manager.load_standalone_module("c:/Users/ahmadardie.r/Documents/my-trash/magik_practice/2023-08-15_at_10hours/rpc_example")

  a << rpc_example_activation_plugin.new()

  a.activate_dialog()

  # ========== if you wanna see all loaded modules, including your own

  sw_module_dialog.open()


#+end_src
** Once again, not to self, when searching for field names. Do this (example):

#+begin_src magik
  
  _for item _over pl_map.current_map.database.collection(:electric,:eo_service_point).all_field_names() _loop
														write(item)
										     _endloop

#+end_src

* Day 26
** writing to an XML, for selected objects
#+begin_src magik

  _global write_map_selection_to_xml <<_proc@ write_map_selection_to_xml(a_xml_file)
					       # Get the first app ( not a good idea, but will be ok for demo)
					       _local an_app << smallworld_product.applications.an_element()
					       _local map_mgr << an_app.plugin(:maps)
					       _local curr_sel << map_mgr.current_map.current_selection
					       sub_ele_rope << rope.new()
					       _for each_geom _over curr_sel.fast_elements()
					       _loop
						       a_rec << each_geom.rwo
						       _if a_rec.rwo_type _is :eo_service_point
						       _then
							       a_name << a_rec.usage.write_string
							       sub_ele_rope.add_last( simple_xml_thing.new(a_rec.rwo_type,_unset,{:usage,a_name}))
						       _endif
					       _endloop
					       # Create a top level xml element
					       top_level_xml_ele << simple_xml_thing.new(:selected_records,
											 sub_ele_rope)
					       simple_xml.write_element_file(a_xml_file, top_level_xml_ele )
				     _endproc

  # ========== and then run it

  write_map_selection_to_xml("c:/Users/ahmadardie.r/Desktop/whatever.xml")

#+end_src
** The example above, test the simple_xml_thing(). it essentially creates a tag like structure, with attributes (like <h1 color="red"></h1>)
** Make sure to edit the one below
#+begin_src magik

  _global show_xml_content <<
  _proc@show_xml_content( a_xml_file)
	  a_xml_doc << simple_xml.read_document_file(a_xml_file)
	  _for each_ele _over a_xml_doc.elements.fast_elements()
	  _loop
		  _for each_sub_ele _over each_ele.elements.fast_elements()
		  _loop
			  an_name << each_sub_ele.xml_attributes["name"]
			  write("RWO ",each_sub_ele.type," with Name ",an_name)
		  _endloop
	  _endloop
			   _endproc

#+end_src
** serial_xml_thing practice
#+begin_src magik

  _global write_map_selection_to_xml <<_proc@ write_map_selection_to_xml(a_xml_file)
					       # Get the first app ( not a good idea, but will be ok for demo)
					       _local an_app << smallworld_product.applications.an_element()
					       _local map_mgr << an_app.plugin(:maps)
					       _local curr_sel << map_mgr.current_map.current_selection
					       rope1 << rope.new()
					       _for each_geom _over curr_sel.fast_elements()
					       _loop
						       a_rec << each_geom.rwo
						       rope1.add(a_rec)
					       _endloop
					       # Create a top level xml element

					       a_xml << serial_xml_thing.write_thing_to(rope1, a_xml_file)
				     _endproc

  # ========== and then run it

  write_map_selection_to_xml("c:/Users/ahmadardie.r/Desktop/whateverSerial.xml")


#+end_src


** Now read it as-is, no changes

#+begin_src magik

xml_read << serial_xml_thing.read_thing_from("c:/Users/ahmadardie.r/Desktop/whateverSerial.xml")

#+end_src

** From previous notes, our struggle to find the record is due to to this (please write this properly)
#+begin_src magik

print(sw_app.plugin(:maps).current_map.current_selection.an_element().rwo.source_collection.all_fields)

#+end_src

* Day 27
** No need selection. Answers to question 4
#+begin_src magik

  sw_app.plugin(:editor_manager).sys!slot(:embedded_viewer).sys!slot(:editors)[:|electric.eo_service_point|].current_object

    # when we print sw_app.plugin(:editor_manager) we get a listing including slots
    # can change it to cable segment or anything

#+end_src
** Note the usage of sys!slot is becoz the slots are private (we do the same thing with methods with sys!perform).
** Later must check make_geometry method. Apparently, a strategy is to add location later (after rt.run(), where rt is a record_transation). Its becoz location fields are not mandatory. And mandatory are usually common for all records. So one strategy is to create single property list for mandatory fields, and upload the rest (locations, etc..) from a .csv file
** For answer 5. if you were to use the bounds by itself, you'll only get 1 hypernode. But by increasing buffer, you get 5, as can be seen by the map

#+begin_src magik

  _block
	       _local a_ds << gis_program_manager.databases[:electric]
	       _local a_coll << a_ds.collections[:sub_substation]
	       _local all_hype << a_ds.collections[:eo_network_hypernode]
	       _local a_rec << a_coll.an_element()
	       _local sw_app << smallworld_product.application(:sweo_dm_user)
	       _local curr_map << sw_app.plugin(:maps)
	       curr_map.get_active_map_view().goto(a_rec)
	       _local a_extent << a_rec.extent
	       _local p1 << predicate.interacts(:pin1,a_extent)
	       _local p2 << predicate.interacts(:pin2,a_extent)
	       _local results << all_hype.select(p1 _or p2)
       _endblock

#+end_src

** Proper answer

#+begin_src magik

  _block
	  _local a_ds << gis_program_manager.databases[:electric]
	  _local a_coll << a_ds.collections[:sub_substation]
	  _local all_hype << a_ds.collections[:eo_network_hypernode]
	  _local a_rec << a_coll.an_element()
	  _local sw_app << smallworld_product.application(:sweo_dm_user)
	  _local curr_map << sw_app.plugin(:maps)
	  curr_map.get_active_map_view().goto(a_rec)
	  _local a_extent << a_rec.extent

	  _local a_pseudo_area << pseudo_area.new_for_world(a_extent,a_ds.world)
	  _local a_buffer << a_pseudo_area.buffer(5000)
	  a_buffer.world << a_ds.world
	  _local p1 << predicate.interacts(:pin1,a_buffer)
	  _local p2 << predicate.interacts(:pin2,a_buffer)
	  _local results << all_hype.select(p1 _or p2)
	  print(results)
  _endblock

#+end_src

** unit conversion

#+begin_src magik

  unit_value.new().value_in()

  unit_value.new(20,:feet).value_in(:mm)

#+end_src

* Day 28
** If we open Suite Admin -> Ace Config -> (select EO) Object Properties -> We get to see visibile feld (Electric DM -> ELectric -> Equipment -> Service Equipment)
** Was busy this day with Fiverr (huhuhu)
** 
* Day 29
** Coordinates systems
#+begin_src magik

  gis_program_manager.databases[:electric].user_visible_coordinate_systems
  # heres another one
  gis_program_manager.databases[:electric].collections[:eo_service_point].an_element().location.coord.x

#+end_src

** Converting a coordinate

#+begin_src magik

  from_cs << gis_program_manager.databases[:electric].user_visible_coordinate_systems[:|British National Grid (mm)|]
  to_cs << gis_program_manager.databases[:electric].user_visible_coordinate_systems[:|Long-Lat WGS84 (degree)|]
  trans << transform.new_converting_cs_to_cs(from_cs, to_cs)

  sw_app << smallworld_product.application(:sweo_dm_user)
  a_coll << gis_program_manager.databases[:electric].collection(:eo_service_point)
  a_coord << a_coll.an_element().coordinate

  converted_coord << trans.convert(a_coord)

  sw_app << smallworld_product.application(:sweo_dm_user)

#+end_src

** Changing coordinate system

#+begin_src magik

# we havent tried this
  sw_app.projection <<
  application_coordinate_system.new_from(v.world.coordinate_system)

#+end_src

** Exercise 5 (?)
*** get objects from current window
*** for line or area, just list ID and status, no need for geom_x and geom_y
* GUI Practice
** Key words to searh for in core document
*** GUI control classes
*** Rearrange the following later based on control panel component (in core doc)
*** message group
*** GUI containers
*** Meal Menu example
** How to 
#+begin_src magik

  ==============================
e
an_action << sw_action.new(:sample1, :caption, "just a sample")
control_panel_component.add_control_panel_action(an_action,
						 :comment, "some comments"
			)
control_panel_component.add_event_handler(:action_selected, _self, a_method)

# we create the GUI. add a control for the action

_pragma(classify_level=basic, topic={test}, usage={test})
_method my_component.activate_in(frame)
	## 
	## 
	top_container << rowcol.new(frame, _unset,1
				:row_aligment, "whatever"
				:col_alignment, "whatever-lah")
	button_1 << button_item.new(top_container,"press me")

	.self.action(:views).place_control_on(button_1)
	.self.build_gui(pw,:width, 155, :height, 350)
	
_endmethod
$

#+end_src
* Day 30
** We're learning authorixation, not much code this time
**
#+begin_src magik

  print(gis_program_manager.authorisation_view.current_groups)
  print(gis_program_manager.authorisation_view.current_user)

#+end_src
** enumerator (extensible enumerator)
#+begin_src magik
  print(gis_program_manager.databases[:electric].collections[:eo_service_point].field(:status))
# and check :type dd_field_type(eo_status) . it will be the same as show in extensible enumerator under the admin suite

#+end_src
* Recent tricks
** Instead of losing code through mountains of lines and errors. I recently did this

#+begin_src magik

  _for i _over a_coll_sp.an_element().physical_fields()
  _loop
	  write(i)
  _endloop
  a_coll_sp.an_element().raw_values_as_vector()[1]
  print(a_coll_sp.an_element().cs_as_property_list())

#+end_src
* Day 31:
** We learned something about alternative and checkpoint management.
** A lot of interesting stuff but useless for now

#+begin_src magik
File usage for the current alternative:

------------------------------------------

_block
        _local ds << gis_program_manager.cached_Dataset(:electric)
    _local fle_usg << ds.file_usage(:this_alt_only?,_true)
    ds.dump_file_usage(fle_usg)
_endblock

 

File usage for all:

-------------------

_block
        _local ds << gis_program_manager.cached_Dataset(:electric)
    _local fle_usg << ds.file_usage()
    ds.dump_file_usage(fle_usg)
_endblock

#+end_src

** cached_dataset to get checkpoint information

#+begin_src magik

  ds << program.cached_dataset(:electric)
  print(ds.checkpoints[1])
  write(ds.checkpoints[1].user_name)
  write(ds.checkpoints[1].time_created)

  # ===== can also create current alternative info
  write(ds.current_alternative_details)

#+end_src

** 

* Day 32:
** We learned how to add a new field for the record "Service Point". 
** We opened the Case Tool and we zoomed into the service point. We added a new field. We did a "check" and "apply". we clicked update both in the ACE and outside. We make sure the checkpoint is writable (clicked through the Version Management inside ACE), before we commit with a new checkpoint name. We restarted the app to see the changes. 
** To show properties of GUi elements:
#+begin_src magik


  # example
  debug_print(label_item)

#+end_src
* Extra class/lessons
** select an object, right click & display internals (current map). This gets the internal world. And you can check the hypoernode (And clicking goto corresponding to pin1 and pin2 gets these)
* Magik errors, GUI practice and Databus

#+begin_src magik

Loading C:/Users/ahmadardie.r/Documents/my-trash/magik_practice/2023-10-18_at_13hours/ardies_reader\source\ardies_reader_activation_plugin.magik
     Error (parser_error): on line 13 in file "ardies_reader_activation_plugin.magik"
_method ardies_reader_activation_plugin.activate_dialog()
^
No such exemplar: ardies_reader_activation_plugin

#+end_src

** What have we done so far
*** we discovered simple_list
*** we discovered identifier, which for some reason doesnt work
*** discovered accessing values from simple_list and moving them to a label_item
*** we discovered tree_item
** When in doubt, always go back to our Meal Menu example
** Some random coding
#+begin_src magik


  # dont know how I did this
  # this is probably for initializing before you do anything
  # useful with databuses
  pl_map.define_shared_constant( :databus_producer_data_types,
			       {whatnow, :record_selection}, :public)



  # this is pretty straightforward stuff
  pl_e.databus.request_data(:current_document)[1]



#+end_src

** Setting trail through databus, but inside a method

#+begin_src magik

  # To set the current map’s trail, your plugin must be registered with the application databus as a producer of the :set_map_trail data type:
  my_plugin.define_shared_constant( :databus_producer_data_types,
				  { :set_map_trail },
				  :public )
  # In the plugin, when you want to set the trail, use a method like this:
  _method my_plugin.set_trail( a_geometry )
	  _self.databus_make_data_available(:set_map_trail,
					    {_self, a_geometry})
  _endmethod
  # The geometry supplied on the databus is converted into simple linear geometry and then into a trail.


#+end_src

** Loading the standalone module, not always used in practice. But useful under some circumstances
** Loading a standalone module
#+begin_src magik

sw_module_manager.load_standalone_module("c:/Users/ahmadardie.r/Documents/my-trash/magik_practice/2023-09-04_at_16hours/rpc_example/")

#+end_src
** geometry_set_for_trace_drawing( nf_link )
** _self.application.databus.request_data( :trace_results )
** Terms:
*** Customizing the network analysis engine
*** The idea below may not be important

- create scanner (our_program.geometry_scanner(:point))

- create bounding box (.buonds)
start scanner  (.start_scan())
- get (.get())
-
node_at

pseudo_node.new_for_world(geom,:electric)

network_follower.trace_out(node1)

network_follower.shortest_path( node1, node2, _gather params )
* Topics:
** Magik components and conponent frameworks
** GUI Containers and Controls
** Alphabetical Document List
** Developing Interactive Applications
** Using the Application Framework Architecture
** Working with Geometry
* Databus more of it
#+begin_src magik

  an_element << gis_program_manager.databases[:electric].collections[:eo_service_point].an_element()

  a_geom << an_element.geometry_set(gis_program_manager.databases[:electric].world)

  pl_map.databus.make_data_available(:set_map_selection, {pl_map, a_geom, :add})

  pl_map.goto(a_geom)

#+end_src
* Read on VMDS from here:
** https://wiki.gis.com/wiki/index.php/VMDS
* How to clone the SmallWorld repo
** Make sure your endpoint security VPN is enabled and connected (your tray below), using staff password
** Download and install the Github Desktop app
*** [[https://redplanetsolutions.sharepoint.com/:u:/s/rpstnb/EeKnOrTrblNEminzerOFTjcB-RLhOIP5s1bUqSKz5BSlVw?e=bbusAw][Github Desktop]]
** Login below
*** http://192.168.3.66/users/sign_in
*** username and password 
*** Change to your desired password
** Login into Github Desktop with the new password
** Choose your desired directory/folder (can choose default, make sure its not the same as our previous SmallWorld)
* RWO (SmallWorld)
** they have 2 unique fields, rwo_type and rwo_code (a name and integer code). 
** RWO definitions - they are defined like tables (you can create it from Magik code)
** What are "Views on RWO"?
** RWO sets
*** It seems to be its own thing
*** heterogenuous (not from single source) set of records across collection and dataset.
*** ds_collection is also an RWO set
*** We can use predicate when searching in rwo_set
*** There is an RWO set API, all classes inheriting from dataset_collection_mixin implement RWO set API
*** Using predicate in RWO allows searching of fields regardless of dataset source.
#+begin_src magik

my_areas << my_rwos.select(:field, {:name})

#+end_src
* Alteia and self-learnt topics 
** Synonyms
*** Site = Project
*** 
** User roles 
*** Manager
**** Company manager has permission to create datasets
**** Domain manager can activate custom analytics
*** User
*** Contributor
*** Operator
** What is a survey
** CSV
*** We apparently are using the CSV file to localize the information 
*** Often in the form of
X, Y, Z
524510.928, 324634.025, 2.446
524524.29, 423585.665, 2.448
** Machine Learning in electric utilities (https://www.datarevenue.com/en-blog/machine-learning-for-energy-transmission)
*** Common risks used in energy transmission
*** prevent power grid failure
*** prevent brownouts with AI prediction
*** balance the grid
**** transmission operators spend millions each year fixing fixing planning mistakes (too much or too little power). Last correction either by buying more power, or compensating power plants for excess
**** Machine learning is the most accurate method available to forecast renewable energy output. Advanced method like Long Short-Term Neural Networks (LSTMs), AI can weigh many factors - wind, temperature, sunlight, humidity forecases, and make predictions
*** detect energy theft
*** differentiate power system disturbances from cyber attacks
#+begin_quote

pip install alteia

#+end_quote
*** use config-connection.json to store username and password and other configs, like public endpoint of Alteia, dictionary providing connection config
*** this is documented in 
*** configuration options documented in alteia.core.config.ConnectionConfig
*** the use case shown is rather specific. using a VERY simple Python script to calculate "fuel consumption" as a function of load, lenfth, and delta_z (elevation delta).
*** On adding custom analytics to end-to-end workflow. 
**** Example is Rust Detector
**** We need to use Docker for this
*** On Docker:
**** The process of creating is simple. Usually a config file just like alteia SDK
**** However reasons NOT to use Docker include: 
***** Building a small project. Becoz you dont need to host it. Docker involves several configs like Docker files and such. Which can make it complicated
***** Docker images are not entirely portable. A Docker build on Linux, still needs Linux to run. So we usually run it inside Linux virtual environment installed on Windows
***** Dockers are best for console-based apps, and even web apps. Not meant for Desktop apps with rich GUI
** Discovery
*** Upon exploring 1 site (FPL Satellite Demo), we discovered the compare tool
*** When comparing we discovered vegetation encorachment data
*** Vegetation management is expensive maintenance work for disctribution & transmission infrastructure. Interesting --> Data prediction usage is species identification and growth rates based on weather conditinos and precipitation rates
*** Traditionally we have always relied on combination of manual surveys and spatial assistance from remote sensing data
*** We now have deep leaning assisted workflows, using satelllite imagery, drone images, 3D data
*** LiDAR
**** It is frequently mentioned as a data source
**** https://www.jouav.com/case-study/lidar-mapping-malaysian-border-roads.html
**** Its basically like a bat sonar, but uses light pulses instead of sound waves
**** Malvus Sense Sdn Bhd -->  Locally unique challenges: Lots of rain, dense forests, places emphasis on waterproofness of drones and penetration of radar. Legal compliance of the flight (so deathly boring), apply for air space from Malaysian Sports Aviation Federation (MSAF), flight bandwidth to 1 km
**** Here ='s  good article on vegetation encroachment in a Malaysian context.
**** https://www.mdpi.com/1996-1073/14/12/3393
*** But LiDAR's are expensive, Satellite data can cover a wide area at a relatively low cost?
** Basic:
*** Energy basic is a complex network of power plants, transmission lines, substations, distribution lines
*** generation = creating electrical power from other forms of energy
*** transmission = moving this electricity from power plant to population centers using HV
*** distribution = delivery of power to individual houses/etc via LV
*** Energy grid operators are using AI in key areas:
**** asset management = AI enabled sensors identify issues befoe problems. Also, historical data, helps maintenance schedules
**** grid operations = real time monitoring of power flow
**** load forecasting = predicting future demans and customer behaviour
**** decision making = where to build new power plants
*** [[https://x2n.com/blog/how-utility-companies-are-using-satellite-technology/][Satellite datxsa]]
*** [[https://www.bloomberg.com/press-releases/2020-10-13/alteia-accelerates-the-deployment-of-its-enterprise-ai-solutions-and-announces-global-alliances-with-ge-digital-and-microsoft][Alteia joins forces]]
**** Alteia joins forces with Microsoft (bringing VI to Azure)
**** Alteia joins forces with GE Digital 
**** Alteia = technology specialist & GE Digital = vertical leader
**** predictive maintenance can capture knowledge?? Becoz staffs retire??
**** 
* Meeting (soon we might need to move meeting into its own place)
** https://www.scribd.com/document/388790080/Sparc-t8-m8-Servers-Faq-3864324
*** What is SPARC?
** I dont understand, haha??!!
** Sabah Energy!??
** TNB GIS CR
*** PNI -> Physical Network Inventory (Fibre??)
*** Active Centralized LV Database ??
*** 
** IQGeo accepts input from Smallworld - Posgres
*** provides telecom, fiber, and utility network operators with the industry's most innovative geospatial network management software solutions.
** Cliffhanger - Atlas (elastic search) accepts dataa from SmallWorld
*** elastic search
** Geomagic GeoNAM - 
*** Cathodic protection - Oracle
* Licensing:
** How do we know everything WITHOUT reading everything
** [[https://www.gegridsolutions.com/products/applications/geospatial/ger4240_oraclesolutions_r6.pdf][Smallworld Oracle]]
*** Smallworld On Oracle allows for the storage of all Smallworld spatial and non-spatial data within an Oracle environment
*** Oracle Spatial simple geometry type
**** point
**** polyline
**** polygon
*** Oracle Spatial is also used to manage address information
**** Notice the separate elements of address and the geographical location of the addresss
**** Address is considered non-spatial information, and is already present in exisiting enterprise system (Customer Relationship Management
**** This provides interesting solutions such as: linking a customers location to network for outage management
**** Seamless integration between Smallworld and Oracle through => publishing one way to Oracle (spatial data too) => 2-way sync between both
** GE Asset Management Products
*** Smallworld Core
**** 3 levels of using the app -> Core, View and Developer
**** full database access
**** Database technology -> direct, cached & replica
*** Developer license includes access to Case Tools
*** Core is usually for system admin, and Developer is FAR too advanced
*** Google Map Viewer
**** Its sold as annual subscription, per end user device (meaning no limit number of GE apps)
**** Smartphone
**** Laptop
**** PC
**** Server
* Links:
** [[https://www.pix4d.com/blog/ten-basic-terms-photogrammetry-knowledge/][pix4d]]
*** Initial and computed parameters => parameters like geometry, position & orientation => pix4d will actually produce computed ones which are more accurate. 3D models with accuracy within a few centimetres, it can reaach industry standards like Bureau Veritas, meaning more applications
*** RTK and PPK are GPS correction techniques
**** RTK happens during drones or survey, with a GNSS RTK receiver 
**** PPK complements lack-of-RTK or no tie points, with a GNSS base station. (both have pros and cons)
**** Tie point, point common in several images. No idea
**** Ground Samping Distance => fancy name for resolution, acheived by distance of flying to the ground
**** 
** [[https://learn.arcgis.com/en/projects/get-started-with-arcgis-drone2map/][ArcGIS Drone2Map]]
*** Drones take 2 types: Nadir (straight down) Oblique (angled)
*** Nadir images can be used to create 2D Orthoimages, several can be combined to create orthomosaics, to create basemaps
*** Oblique images => 3D point cloud => 3D Mesh => navigable 3D diagram
*** 
* Coordinate (also move to a different note)
** [[http://qgismalaysia.blogspot.com/2012/07/did-you-use-right-wgs84.html][did you use the right WGS84?]]
*** Has some interesting REAL LIFE details, including formulaes on converting coordinate systems
** [[https://epsg.io/?q=Malaysia&page=4][Check this out, combination of WGS and UTM]]
*** Whatever, just check it out
* Alteia upload
** When we upload a survey, we have yet tried the + METADATA option
** We need to read this one, then rewrite:
*** [[https://help.alteia.com/data-capture-and-ingestion/upload-csv-as-a-vector-file][upload CSV as a vector file]]
** Analytics will produce raster and vector files that can be downloaded
** Adding single or several pictures from the ground (DSLR) to an existing aerial project (in its annotations) is possible
** There are 3 layers
*** Site
*** Survey
*** Base, mostly from orthomosaic from the photogrammatery processing
** Data contextualization
*** Vector styling and custom
*** The fiter tool allows view on single attribute with a histogram
*** One can change the geometry of the vector shapes: rotate, relocate, add lines or polygons
*** Split view and compare view
**** Compare: slider, split, overlay
*** Grid digitization can be downloaded as .geojson
** Fuse
*** Measurement tool, one can measure elevation by drawing a line between 2 points
*** Vegetation fraction data (ratio), from orthomosaic, reflectance and spectral, can be downloaded as .geojson
*** thermal map
* Site:
** During site creation, can define global CRS, then local CRS, which can be:
*** single local-global CSV
*** separate CSVS
*** JXL
* SmallWorld GIS mehh:
** https://www.reddit.com/r/gis/comments/ta8645/arcgis_could_always_be_worse_it_could_be/
** 
* Data preparation (please arrange later)
** https://pubs.rsna.org/doi/full/10.1148/ryai.2019190126
* An interesting link to ArcGIS geometry methods
** https://pro.arcgis.com/en/pro-app/latest/arcpy/classes/geometry.htm
* [[https://smallworld.gedigitalenergy.com/documentation/sw52/en/swDocs5.htm#../Subsystems/AppDev/Content/Geometry/GeometryAnalysis.htm][geometry analysis]]
* [[https://docs.qgis.org/3.28/en/docs/pyqgis_developer_cookbook/geometry.html][Read about PyQGIS?]]
* Playing around:
#+begin_src magik


  geom1 << sw_app.databus.request_data(:map_selection)[2]
  geom1.distance_to(geom2)
  # also can
  geom1.intersection(geom2)

#+end_src
* Tree example:
** e:/SmallWorld/core/sw_core/modules/sw_common/tree_examples/source/
** 
* Ground Control Point
** [[https://www.propelleraero.com/blog/how-to-optimize-your-ground-control-point-placement-for-drone-surveying/][how to optimize]]
*** GCP's reduce the margin of error from metres to centimetres
** [[https://docs.qgis.org/3.4/en/docs/user_manual/plugins/core_plugins/plugins_georeferencer.html][QGIS Georeferencer plugin]]
*** According to this, its a simple as marking a point on a jpeg/raster, and state its accurate coordinates
*** That alone increases the accuracy of the JPEG
*** Steps --> select multiple points, specify coordinates, choose transformation type(?) 
* Design
** Phase design is a way to split design into parts, so you can post the changes to the DM_TOP . TNB configures it for HV or LV.
#+begin_src magik

  swg_dsn_admin_engine.active_design
  swg_dsn_admin_engine.active_build_phase

#+end_src
** According to slides: design are also versions of a data
** The TOP design is the as-built record
* Our task regarding getting JUPEM and ACAD data from a demand point, in the form of json data
** The SOC definitions for a database are stored in the top alternative of the ACE partition (by default, this is held in the file ace.ds). Thus, by interrogating all the SOC definitions in an ACE partition, all the user and Case datasets in a database can be identified.
* Meeting October (Should REALLY move it to it own place)
** GridOS - I have no idea what that is
** They no longer call their solutions as GIS, they call it Geospatial Network Management
** ESRI Utility Network - its also a web-based system, so they can use REST API's
** In the end nobody cares, hahaha
** Smallworld journey to GridOS 2024-2025
* Meeting October 2 (Akisha) GE GSA Product
** partnered with spatial eye
** What is ILMAS, TNB Datalake?
* From the slides:
** A confusion I had, a commit and a checkpoint is not the same thing. In Git workflow, a commit can always be reverted back to (come back to, undoing recent changes). In SmallWorld, a commit is saved just for the app when restarting. You need to create a checkpoint for a commit to go back to. So, a new commit overwrites a previous commit, so you lose previous commit. 
* Design stuff: 
** How to get current design
#+begin_src magik


swg_dsn_admin_engine.active_design

#+end_src
** We keep forgetting we can get the name of the rwo from the  current selection
#+begin_src magik

pl_map.current_map.current_selection.an_rwo()

#+end_src
** getting collections
#+begin_src magik

gis_program_manager.databases[:jupem_land].collections
  
#+end_src
** this matches the external name in editor plugin, so it matches
#+begin_src magik

gis_program_manager.databases[:jupem_land].collection(:cgis_jupem_land_parcel).external_name

#+end_src
** things we tried, including converting into rwo, and then converting into geometry_set
#+begin_src magik

  a_land << gis_program_manager.databases[:jupem_land].collection(:cgis_jupem_land_parcel).rwo_set()

  a_sp_rwo << a_sp.source_rwo_records()

  a_sp_rwo.select(:within, a_land)

  a_sp_rwo_g << a_sp_rwo.geometry_set(a_world)

  a_land_g << a_land.geometry_set(a_world)

#+end_src
** Why is this 0
#+begin_src magik

a_sp_coll.select(predicate.within(:location, a_land.an_element().cgis_area)).size

#+end_src
* Nothing
** We got this randomly from a documentation
#+begin_src magik


  an_island.area

#+end_src
** This returns the error "spatial relations are not defined on point"
#+begin_src magik

  _block
	  _local pl_map << smallworld_product.applications.an_element().plugin(:maps)
	  _local a_sp_coll << gis_program_manager.databases[:electric].collection(:eo_service_point)
	  _local a_land << pl_map.current_map.current_selection
	  _local a_world << gis_program_manager.databases[:electric].world
	  _local a_sp_coll_g << a_sp_coll.geometry_set(a_world)
	  _local results << a_sp_coll_g.select(:within, a_land)
	  print(results)
  _endblock

#+end_src

#+begin_src magik

_block
	  _local pl_map << smallworld_product.applications.an_element().plugin(:maps)
	  _local a_sp_coll << gis_program_manager.databases[:electric].collection(:eo_service_point)
	  _local a_land << pl_map.current_map.current_selection
	  _local a_world << gis_program_manager.databases[:electric].world
	  _local a_sp_coll_g << a_sp_coll.geometry_set(a_world)
	  _local results << a_sp_coll_g.select(:within, a_land)
	  print(results)
  _endblock


a_land_coll << gis_program_manager.databases[:jupem_land].collection(:cgis_jupem_land_parcel)

a_sp << pl_map.current_map.current_selection

a_world << gis_program_manager.databases[:electric].world

a_land_coll_g << a_land_coll.geometry_set(a_world)

#+end_src
** Documentation
#+begin_src magik

  
  a_sp << pl_map.current_map.current_selection # this is a service point
  a_land << gis_program_manager.databases[:jupem_land].collection(:cgis_jupem_land_parcel)
  a_land.select(predicate.interacts(:cgis_area,a_sp.an_rwo().location))


#+end_src
** Spatial predicates:
*** another example I discovered
#+begin_src magik

  _block
	  p1 << predicate.gt(:timestamp,  ds_time.value_from_string("1/2/2022"))
	  what << a_coll.select(p1).result
  _endblock 

#+end_src
* Meeting (TELECOM to PNI)
** only passive equipments
** PNI includes many more telecommunications including satellit, radio ,etc. But we are only cover Fibre
** Fibre networks like electric utility has "splittings" using street cabinet splitters, LOL
** splitters are passive networks. amplifiers are active networks. Our SmallWorld can only model or map the passive networks in our PNI
** FTTC, FTTB, FTTH (Fibre to the Cabinet, to the Building, to the Home)
** Restriction by design
** What is a manifold
* equality_property_list & property_list. In general, "equals" and equalitiness are less strict. Although there is that "identity" issue (_true _false)
#+begin_src magik

  _block
	  _local pl1 << property_list.new_with("one", "the number one", "two", "the number two")
	  write(pl1["one"])
	  _local epl1 << equality_property_list.new_with("one", "the number one", "two", "the number two")
	  write(epl1["one"])
  _endblock

#+end_src
* From the documentation (on RWO)
** RWO sets - Dataset collection classes, such as ds_collection, are functionally RWO sets and have the same behaviour as classes such as rwo_set. Dataset collection classes, however, are always homogeneous and their records come from a single dataset.
* Meeting (PNI), (Lukman)
** The UI at first glance is VERY similar to Electric Office
** I have no idea what Im looking at 
* To increase speed of reads in the future, use the .result method [[https://smallworld.gedigitalenergy.com/documentation/sw53/en/swDocs5.htm#../Subsystems/AppDev/Content/Geometry/GeometryAnalysis.htm][(link)]]
** ...Dataset geometry sets are lazy-evaluated—they do not directly contain any geometry, instead they hold a number of parameters (world, geometry fields, bounding box and so on) that specify what geometries the dataset refers to...
** ...However, laziness implies that the protocols elements() and size are slow, because the set is evaluated each time they are used. When a set is used several times, it is advisable to evaluate it once with the method result then use the plain equality geometry set that this returns...
* Meeting (14/12/2023) Adam
** Cluster analysis is unsupervised learning
** Whatever, Machine Learning is boring, hahaha
* From asset_search_plugin.magik, converting string to coordinate object
#+begin_src magik

  # make sure to analyze the following code later

  _pragma(classify_level=restricted)
  _private _method asset_search_plugin.get_coord_from_string( a_string )
	  ## 
	  ## 

	  app << _self.application
	  app_coord_system << app.coordinate_system
	  trans << transform.new_converting_cs_to_cs( .search_coord_system, app_coord_system )

	  pos << a_string.split_by( %, )
	  a_coord << coordinate.new( pos[2].as_number(), pos[1].as_number() ).transformed( trans )
	  _return a_coord
	
  _endmethod
  $

#+end_src
* Renaming method from this [[http://sw-gis.wikidot.com/magik-adv-lang][link]] (turns out to  be useless solution, haha)
#+begin_src magik

  oldmethod << map_manager.method(:print_string)
  newmethod << :print_ardie
  map_manager.define_method(newmethod, oldmethod.value, _false )
  # We can also try something else, once we create exemplar test2 with the method somemethod()
  somemethod << test2.method(:somemethod|()|)
  map_manager.define_method(newmethod, somemethod.value, _false )
  # ===== we managed to stop the object view from loading!!
  oldmethod << :goto_object|()|
  asset_search_plugin.define_method(oldmethod, somemethod.value, _false )
  # ===== we managed to get the private slots!!
  oldmethod << :goto_object|()|
  asset_search_plugin.define_method(oldmethod, _proc () write("goodbyeeee"); print(_self.sys!slot(:results)[1])  _endproc , _false   )
  # ===== we dont need to block goto_object, we can actually block asset_search_plugin.goto_coord( a_coord )
  # ===== DO SOMETHING

#+end_src
* [[http://tnbelectricaleng.blogspot.com/2009/12/substation-categories-type-design.html][PMU, PPU, SSU, PE -> What does it all mean in our TNB Substation terminology]]
** PMU -> Pencawang Masuk Utama (Transmission Main Intake)
*** interconnection point between 132kV or 275kV to the distribution network
*** think of distribution as something like "extension"
*** transformations are as follows
*** 132/33 kV, 2 x 90 MVA
*** 132/22 kV, 2 x 60 MVA
*** 132/11 kV, 2 x 30 MVA
** PPU -> Pancawang Pembahagian Utama (Main Distribution Sub-station)
*** can think of extension or connection between 33kV to   11kV
*** has standardized transformation of 33/11 kV
** SSU -> Main Switching Station (Stesyen Suit Utama)
*** dedicated supply to bulk consumer
*** as transfer (extension) from a PMU/PPU to a load centre for  further localized distribution
** P/E -> Pencawang Elektrik (Distribution Substation)
*** injection points from 11 kV, 22kV, and sometimes 33 kV to low voltage (415 V, 240 V)
* Meeting (26/12/23)
** ADMS
** cim model (format)
** sub level DNOM (format)
** 3  types of information: cim, cim profile, cim mapping
** ADMS Tools
*** Earthing Tool
*** 
** Hey, I already tried the Circuit Build Tool
** We must build the primary level circuits (substation) first before feeder level 
** Under SW menu, there  is CIM  exporter  under GIS adapter.
** 
* GIS Adapter
* Reading about Oracle databases (we may remove this later)
** one can open SOC definitions (which has many htings such as connection parameters), with the method manage_soc()
*** We use this everytime, coz when we start a session, we always open a DB connection. If no connection, we can pass parameter like this: manage_soc("h:\cambridge_db\ds\ds_admin")
*** This is usually a directory containing ace.ds
* hotfixes  in our TNB distribution
** load_application_fixes.magik is overly long, but it actually very simple. Depending on the user type session, it loads custom directory hot fixes (we still cant locate folders exactly)
** You can find this file under d:/Smallworld/TNB_GIS/DIST/modules/cgis_custom_patches/hot_fixes/
** The load_application_fixes.magik is actually loaded  (along with many other files in the same directory), through this -> load_fixes.magik which adds a startup procedure
#+begin_src magik


  smallworld_product.add_startup_procedure( _proc @load_tnb_fixes()
						  #load_file_list(system.getenv("LOCAL_HOT_FIX_PATH")+"\modules\cgis_custom_patches\hot_fixes")
						    _if system.os_name _is :windows
							_then
								load_file_list(system.getenv("LOCAL_HOT_FIX_PATH")+"\modules\cgis_custom_patches\hot_fixes")
							_else
								load_file_list(system.getenv("LOCAL_HOT_FIX_PATH")+"/modules/cgis_custom_patches/hot_fixes")
							_endif
					  _endproc, 1 )

#+end_src
** Notice that it uses load_file_list, thats something new. We can actually load all files in a directory using this command
** This file in turn is loaded from -> d:/Smallworld/TNB_GIS/DIST/modules/dist_gss_custom/config/magik_sessions/source/register.magik
** We may need to read about register.magik (probably simple and quite meaningless)
* What we learnt from Task 6
** We were dealing with duplicates. Running duplicates required a single special variable to work against. For storing unique IDs each time. In our case, there were 3,000,000 records. 
** We used our own logic, not entirely sure if it was an improvement over the bag and elements_and_occurrences() trick
** We were over-thinking on how to deal with _unset. In the case of not wanting to deal with ANY unset field, we can just use a one-liner like the following
#+begin_src magik
  _if a_rec.cgis_reg_structure_group _is _unset _then _continue _endif
  _if a_rec.cgis_installation_id _is _unset _then _continue _endif 

#+end_src
** In our cross-checking of our output data, we had a property_list of bags. It behaved funny in our code (despite behaving normally when using a simpler data outside of our code). All our occurrences were 1!! Its safe to stick to string as the data and switch to equality_bag, that will solve most of our occurences issues.

#+begin_src magik

  .pl_dup[region] << equality_bag.new()
			
#+end_src
* What about Task 7
** We obsessed about a method called from a button, which led to confusion, becoz we forgot  how to create
** We abandoned completely (quite painful), using :model for our solution. We now copy and paste the entire activation_plugin.magik which has a number of "meaningless" method such as init_actions(), which merely establishes standard menus and such
** gui.xml is also "meaningless", when creating a popup for example, onee can use the same exact gui.xml, to link the popup to the same plugin name (plugin name is usually in module.def)
** .editor_required( tree, row_index, column_id, an_agent ) is a required method that should be defined locally, if we are going to  
*** We then need to define     :editor_required_notifier, :|editor_required()|,     for the tree_item 
** Defining aspect isnt worth it (which will bind together the tree_item and the data that will be eventually be updated everytime we select the dropdown value in the UI, for example)
** Another issue we did not foresee, is if we have for example, fields_1, fields_2, fields_3 (dropdown),  fields_4. And fields_3 and fields_4 are interconnected (for example, extracted from the same catague table). How do auto update the value in fields_4 if for fields_3, we chose a different value. The better decision would be to ignore fields_4 entirely.  Making the logic of the UI simpler
** Using Plugins
*** For the popup, onnly 2 files are needed, the _framework magik file, & the _gui_plugin.magik.
*** And then, we .get_dialog() inside our _gui_plugin.magik, and if it is unset, we create a new dialog calling _framework.new() caching the dialog -> _framework.cache_dialog()
*** with a handle on the dialog activate, if it is the top frame, we activate_relative_to, someday we will need to really understand the second part. 
* Task 8, some learning opportunity, 
*** external Oracle database example. An example that will probably crash the system
#+begin_src magik

  ext_db << gis_program_manager.cached_dataset(:dude_eo)
  ext_db_user << ext_db.user
  ## RPS Change - SNC Web Service Revamp - changed id to sw_id
  sql_query_area << write_string("select area from cgis_sw_jobs where sw_id = ?")
  extdb_stream << ext_db_user.sql_select(sql_query_area, _self.id)

#+end_src
*** The example  below actually works
#+begin_src magik

  ext_db << gis_program_manager.cached_dataset(:dude_eo)
  ext_db_user << ext_db.user
  a_query << "select * from CGIS_SW_JOBS WHERE ROWNUM <= 10"	
  a_stream << a_db.user.sql_select(a_query, _unset )
  a_stream.get_all()[1].p

#+end_src
*** References: https://sql1.wordpress.com/2021/05/22/how-to-select-top-100-in-oracle-2-methods/
** After our  usual set_metadata, for an external Oracle dataset (oracle_objects_dataset.set_metadata()). We need to do some setup for visibility, hittability, selectability
** Suite Administration -> ACE Configuration -> select EO from the list -> Versions
*** IMPORTANT: our user account is also the name of our alternative
** Suite Administration -> ACE Configuration -> select EO from the list -> Object Configuration -> Electric DM (SOC) & Dataset (dude_eo) -> 
** to automatically load a module we created ourselves. We need to register it. The following output of grep are some clues on how this works
#+begin_src magik


  ./config/magik_sessions/source/register.magik:				sw_module_manager.load_module(:cgis_oracle_metadata)

#+end_src

* Something new I lerant today:
#+begin_src magik

  	stop_preds << a_follower.get_stop_predicates()

#+end_src
* search "Activating an application window" in the local or remote doc, for more cool tips on application startup in SW
* search "Add activation controls to the application" for actual plugin information
* Changes I tried to load the meal_menu.magik:
** e:/SmallWorld/electric_office/modules/application_modules/sweo_dm_user_application/resources/base/data/config.xml
** e:/SmallWorld/electric_office/modules/application_modules/sweo_dm_user_application/module.def
** e:/SmallWorld/electric_office/modules/application_modules/sweo_dm_user_application/resources/base/data/gui.xml 
** And the usual LAYERED PRODUCT mods I did, I wrote it once, but forgit it completely
* This is just some random reading on GUI init_actions(). A method which I still dont understand
** Activating any GUI framework, including subclasses such as applications and map GUI frameworks, is a three-stage process:
*** A new instance of the relevant framework class is created and initialised. This includes reading the main configuration file for the framework, if available, and creating an instance of each plugin class known to the framework.
*** The message init_actions() is sent to each plugin. Any plugin can subclass the init_actions() method to create the actions required to provide access to the plugin functionality.
*** The framework is activated — this includes building its user interface in a suitable container, such as a top-level operating system window or an embedded pane of an outer framework. If a GUI configuration file for the framework is available, it is read:
**** menus and toolbars are built up by creating and placing controls for the relevant plugin actions, which must already be created
**** where a plugin is identified as providing the contents of a work area pane, the message build_gui() is sent to the plugin
**** If no GUI configuration file is available then a simple user interface is built with a work area pane whose contents is provided by the framework itself.
*** A plugin can provide custom behaviour for any stage of this process by subclassing a method such as post_init_actions(), post_build_gui() or post_activation().
* More on GUI:
** A common mistake I guess, is not using .new() when activating your dialog from Magik session. Example you have dialog activation from inside start_gui() (custom method). Common mistake is to use module1.start_gui() instead of module1.new().start_gui(). Makes sense, becoz most methods are "protected"
* Ideas about meal_menu_plugin.magik
** Activation_plugin isconfusing for beginners. One can move the start_gui() or activate_meal_menu() to a single plugin. 
* Random  note about storing old values.
** A combined get and set method is also available; this is convenient for preserving the current value while setting a new one:
#+begin_src magik

  my_old_state << my_action.enabled? ^<< _false

#+end_src
* tips from "Identify Source point plugin" 
** Location: D:\Smallworld\TNB_GIS\DIST\modules\functional_modules\cgis_custom_tool_modules\cgis_identify_source_point\source
** Inside the plugin.build_gui(a_container)
*** We can organize gui elements as methods, and the parent container. (Strange, since I though for that to work, it supposed to be a global apparntly doesnt matter). Apparently it works

#+begin_src magik

  _self.create_toggle_items( rc1)
  _self.create_choice_items( rc2)
  _self.create_radio_items( rc2)

#+end_src
** Inside plugin.create_toggle_items(a_rowcol)
*** we place a radio group inside a row_col, inside a groupbox, inside the rowcol passed
*** and in that radio group, we "attach" a radio  child
#+begin_src magik

  toggle_group_box << group_box.new(a_rowcol #, ...)

  toggle_rc << rowcol.new(toggle_group_box #, ...)
  rad_grp << radio_group.new(toggle_rc)
  .gui_items[:substation]    << radio_item.new(toggle_rc,_self.message(:substation), :model, _self)#,   :change_selector, :manage_actions|()|)
  rad_grp.manage_child( .gui_items[:substation], :one )
  .gui_items[:lvdb]          << radio_item.new(toggle_rc#, ...)
  rad_grp.manage_child( .gui_items[:lvdb], :two )
  .gui_items[:pole]          << radio_item.new(toggle_rc#, ...)
  rad_grp.manage_child( .gui_items[:pole], :three )

#+end_src
** Another important point to note is that, the gui_items, store the properties and the value in a GUI element. In this script we put the matching data in that element. And  in post_activation(),  we can connect everything to a singular method.
#+begin_src magik

  _method cgis_identify_source_point_gui_plugin.post_activation()
	  ## 
	  ##
	  .gui_items[:substation].change_selector<<:manage_actions|()|
	  .gui_items[:lvdb].change_selector<<:manage_actions|()|
	  # ...
  _endmethod
  $


#+end_src
*** This allows us to create a conditional, that trigger GUI elements depending on the radio
** Heres something cool too. We connect a method to the change_selector. then we can maatch exactly the data[] and gui_items[]. Eg:
#+begin_src magik

_method cgis_identify_source_point_gui_plugin.selected_substation_type()
	## 
	## Returns the selected substation type
	##

	.data[:substation_type] << .gui_items[:substation_type].value

_endmethod
$

#+end_src
* Oracle SQL  (some tips not present in my tasks)
** [[https://stackoverflow.com/questions/35199084/forgot-oracle-username-and-password-how-to-retrieve][Get forgotten username]]
** [[https://www.positioniseverything.net/ora-65096-invalid-common-user-or-role-name/][Creating new user]]
** [[https://www.positioniseverything.net/ora-65096-invalid-common-user-or-role-name/][grant sysdba privilege]]
** [[https://blogs.oracle.com/sql/post/how-to-create-users-grant-them-privileges-and-remove-them-in-oracle-database][Better granting privilege]]
** [[https://stackoverflow.com/questions/44858475/how-to-grant-user-space-resource-on-the-tablespace-in-oracle-12c][tablespace quota]]
** "Column not allowed here" error can also be caused by single quotes. Basically, just avoi double quotes in SQL. [[https://stackoverflow.com/questions/10501521/column-not-allowed-here-error-in-insert-statement][Single quotes]]
#+begin_src

SQL> insert into test1(identity, student_name) values (1, 'whatever');

1 row created.
  
#+end_src
** [[https://docs.oracle.com/en/database/oracle/oracle-database/19/ntqrf/starting-and-shutting-down-a-database-with-sql-plus.html#GUID-2E99A42E-B675-4EA4-B005-6DBFF1F45B27][startup and shutdown a database instance]]
* Task 9
** Note the brackets/parenthesis around these 2. Important and easy mistake. Avoids assigning True/False to variable

#+begin_src magik

  _if (.a_dataset << gis_program_manager.databases[:dtm_dataset]) _is _unset 
  _then
	  write("cant connect to database")
  _endif

  _if (.a_coll << .a_dataset.collections[:dtm]) _is _unset 
  _then
	  write("unable to get collection")
  _endif

#+end_src
* Task 10
** How to list avilable conditions:
*** [[https://smallworld.gedigitalenergy.com/documentation/sw51/en/swDocs5.htm#../Subsystems/AppDev/Content/Conditions/ConditionsUsing.htm?Highlight=try%20condition][GE docs]]
#+begin_src magik

  condition.print_hierarchy()

#+end_src
** ==========
* Task 11
** Apparently, a phase can be incomplete and still the design can reach be posted
** a phase is an not dependent on design, a separate entity,  hence can even  still be  transitioned to phase complete, AFTER design is posted
*** Even the changes are saved
** Cant really tell anything
*** [[https://sspinnovations.com/blog/smallworld-data-migration/][smallworld internal]]
*** 
* Remembering Task 7
** What is this for?

#+begin_src magik


    _if .items[:selected_conductor].value _is _unset
    _then
	    _self.show_message(_self.message(:select_c_map))
	    _return _false
    _elif .items[:distance] _is _unset 
    _then
	    _self.show_message(_self.message(:give_distance))
	    _return _false
    _elif .items[:distance].value.as_number() _is _unset
    # ... snip ...

#+end_src
** Also task 7
*** we found a different error "unset does understand an_rwo"
*** we can both ignore and use activation_plugin, our meal_menu example doesnt have activation_plugin, so we create the dialog (or accessing the cached one) inside our gui_plugin
*** equality_geometry_set produces an error when pased to the goto() method. Not if sure is jsut local in the script, or ALWAYS
*** pre_activation is always used in the cgis and tnb custom scripts. they apparently run automataicaally before  init(), we gotta test this 
* Task 13
** We basically created a business rule. Some  pretty  cool code stuff we found ut dont know what to write. 
* Task 14
** Inserting a SQL  statement, uses this:
#+begin_src magik

  ext_db << gis_program_manager.cached_dataset(:dude_eo)
  ext_db_user << ext_db.user
  a_query << "insert into dist_transformer_meter values (" + value_string + ")"




  _try _with cond
	  a_stream << ext_db_user.sql_modify(a_query)
	  .what << a_stream
	  # ...

#+end_src
* Task 15 (please complete this)
** rwo_actions
** We added special_actions()
** we tried using the usual _framework.magik, _gui_plugin.magik, for adding an action under the eo_power_xfrmr_inst, but clearly not doable, becoz it  becomes complicated under another plugin 
** We used model. 
** Previously, we put all the elements inside _gui_plugin.magik, passed that object  into framework.new() inside some _activate_plugin.magik. (To describe, we are putting the gui_plugin inside a new framework, framework being like a window with properties like gui.xml and config.xml)
** Now, we used activate_in(). this can be put inside the subclassed model class itself. running the dialog requires some_model.new().activate_dialog()
** Something we might consider:
*** Becoz adding some code we have to "special actions" require {1} the special_action() method {2} the init_actions and {3} assigning the editor  to the class
#+begin_src magik

  # ===== some code

#+end_src
*** That means we can {1} and {2} inside a seperate class, and {3} inside another class. All inside a separate module. (folder with module.def)
** 
* Documentation:
** I  keep forgetting that the reason for .init(), is to not initialize our slots, but to finally create the datatypes for that slot (or maybe something more). Example (from  cycle way, which we should probably downlaod and try, if we are really interested in it)
#+begin_src magik

  def_slotted_exemplar( :create_cycleway_plugin,
		      { { :trail, _unset },
			{ :geoms, _unset } },
		      :plugin )
  $
  _private _method create_cycleway_plugin.init(
			   name, owner, _gather args )
	  ## Initialise slots.
	  _super.init( name, owner, _scatter args )
	  .geoms << equality_geometry_set.new()
	  >> _self
  _endmethod
  $


#+end_src
** (can refer to Developing Interactive Applications: Examples of developing plugins in local docs) actions (user thinks of it as a button) are children of plugins. Which means we can have multiple actions (meaning several dropdown selection in the menu bar) for a single plugin. For this:
*** We add another action using init_actions()
#+begin_src magik

  _method meal_menu_plugin.init_actions()
	  _self.add_action(# ...
		)
	  _self.add_action(# ...
		)
  _endmethod


#+end_src
*** the action calls a method
#+begin_src magik

  _method meal_menu_plugin.activate_second_gui()
	  write("create a dialog or whatever")
  _endmethod
  
#+end_src
*** the message
#+begin_src magik

:activate_second_gui  Activate Second GUI

#+end_src
*** the gui.xml, since we already defined the logical name in config.xml during the first action
#+begin_src xml

  <submenu name="extras" mnemonic_id="extras_m">
    <action name="meal_menu.activate_meal_menu"/>
    <!-- <action name="meal_menu.activate_second_gui"/> -->
  </submenu>

#+end_src
** Magik Language: Behaviour of all classes (10.4 Sending a message to an object)
** Developing Interactive Applications: API to action, plugin and framework classes (2.4 Methods for managing dialog boxes)
** Something to think about, but actually very simple. Whats the difference between a session? a product? an application? a module? a plugin?
*** product is the folder registered under config/magik_sessions/source/register.magik, and eo_open (a child of eo_closed). basically registered under a session. 
*** a module is the name found in module.def (and you load the module under the session as a key :load_modules)
*** an application is the same as a module. Using only XML (no magik code needed), you can either limit or expand applications available to a group of users (admin? users?)
*** a plugin is the class  name itself. But under config.xml, we link a "logical name" to the class name, so in gui.xml we can use the logical name to call the actions.
*** Additional point: init_actions(). allows us to separate th action name to the method name itself. So we can have an action :activate_meal_menu that links to the :activate method. Or :activate_meal_menu links to the :lets_go
* We successfully created a special_actions. 
** We used a separate exemplar, and our own named plugin :editor_adds
** we appended a special variable to that plugin
** init_actions()
** the method connected to the init_actions
** connect the new plugin to the collection itself (using a shared variable like :eo_power_xfrmr_inst) and the overwrite the method .editor_plugin()
** We through we could modify the plugin further using XML files, apparently we dont know how
* popups available in our remote system
#+begin_src magik

  smallworld_product.eo_application().show_alert("hello there")
  # also show_question() and show_message()

#+end_src
* The next thing we should do is see if we can change our plugin to a properly named one. Or maybe see if our eo_power_xfrmr_inst_plugin is actually elsewhere in remote
* Note-to-self:
** The remote apparently puts our tnb_pole_insert thing inside its own module.def called \\10.215.92.21\Smallworld\TNB_GIS\DIST\modules\functional_modules\cgis_dist_application_installer\module.def
* KPI
** technical skill 1
*** new state model
*** setup job server for QAQC in EO demo DB
*** 
** tech skiill 2
*** Gis adapter CIM
*** Config setup
** tech skill 3 
*** GAS, PNI, water
*** Exploration and document preparation
* For our loca SmallWorld setup:
** we wanna make things cool like our remote
#+begin_src magik



_method object.p
	print(_self)	
_endmethod


#+end_src
* We found something, we need to write about this one.
#+begin_src magik


    smallworld_product.get_resource_file("test.txt", "data", :meal_menu_test)
  # found under \\10.215.92.21\Smallworld\TNB_GIS\DIST\modules\functional_modules\cgis_snc_cpp_modules\cgis_snc_asset_report_generator\source\cgis_snc_asset_report_generator.magik

#+end_src
* Each framework has its own GUI.xml and CONFIG.xml, so each module can have several frameworks (GUI framework). We can then activate a second dialog, by passing its own .XMLs into another gui_framwork2.magik (and its made aware of a gui_plugin2.magik through the logical link inside CONFIG.xml)
* Related to engine and add_dependent()
** First of all, in our experiment of using model VS using plugins to open a dialog from another dialog. When linking the engine from the gui_plugin/model. We realized that model doesnt not have the post_activation() method (and probably others).
** So in model, we add these into init(), instead of post_activation()
#+begin_src magik


  ## ===== inside init() if using model, otherwise post_activation()
  ardies_reader_engine.add_dependent(_self)
  ardies_reader_engine.run(.data)
  ## ===== inside init() if using model, otherwise post_activation()


#+end_src
* Task 19:
** Add functionality to the icpp_integration_status module, including a basic tree_item display (with branching data)
** A common error when performing too much intensive read (SW collections)

[[./stuff_i_installed_at_work/resource_error.png]]

** Code that uses sw_tree (simplified, and please test, some stuff might be missing,also havent tested in real life)
#+begin_src magik


  _pragma(classify_level=basic, topic={tnb_validate_checks})
  _method cgis_tnb_validation_checks_gui_plugin.build_gui( a_container)
	  .items[:reports] << sw_tree.new(rc_3,
					  :col_alignment,      :fill,
					  :row_alignment,      :fill,
					  :model,              _self,
					  :selection_notifier,:value_changes_col_cntr|()|,
					  :selection_mode, :many,
					  :data_selector,:result_table|()|,
					  :aspect, :result_table)
  _endmethod 
  

    _method cgis_tnb_validation_checks_gui_plugin.result_table(parent, _optional depth)
	    ## 
	    ## prepare the tree based on the input parameters.

	    tree_table_rope << rope.new()
	    l_key << :|Conductor|
	    l_rope << .items[:xml_group_type].nth_element(1)		

	    _if l_rope _is _unset _then _return _endif

	    l_name << "first item"
	    element << sw_tree_element.new( parent )

	    element.add_content( {:left_spacing, 1,
				  :right_spacing, 1},
				 {label, l_name,
				  :model, _self})


	    _for l_res_val _over l_rope.elements()
	    _loop
		    l_name << "children"
		    l_method_name << l_res_val[2] 
		    chd_element << sw_tree_element.new( element )
		    chd_element.add_content( {:left_spacing, 1,
					      :right_spacing, 1},
					     {:label, l_name,
					      :model, _self})		  		
	    _endloop
    _endmethod
    $


#+end_src
*** Notice that it doesnt behave like a normal function, (returning something). It in fact modifies the parent object passed in. But we have yet tested this theory in real life. We in fact used a normal display_tree for branching data (Eg: from styled_tree.magik in tree_examples)
*** 
** One way to slowly move towards  a single recursive function for tree_list
#+begin_src magik

  _pragma(classify_level=basic, topic={icpp_integration_status})
  _method icpp_status_gui_plugin2.details_tree
	  ## calls the internal int!details_tree
	  >> _self.int!details_tree(.items[:data])
  _endmethod
  $


  _pragma(classify_level=basic, topic={icpp_integration_status})
  _method icpp_status_gui_plugin2.int!details_tree(l_current_pl, _optional p_parent)
	  ## 
	  ##

	  _local l_internal, l_field, l_ss, l_all
	  l_all  << property_list.new()
	  l_all[:substation1] << property_list.new()
	  l_field << property_list.new_with(:voltage,  "11kV",  :id, 999)
	  l_all[:substation1][:ring_main_unit] << l_field
	  l_field << property_list.new_with(:op_area,  "Putrajaya",  :id, 4545)
	  l_all[:substation1][:transformer1] << l_field
	

	
	  l_field << property_list.new_with(:voltage,  "33kV",  :id, 555)
	  l_all[:substation2] << property_list.new()
	  l_all[:substation2][:ring_main_unit] << l_field
	  l_field << property_list.new_with(:op_area,  "Kajang",  :id, 1209)
	  l_all[:substation2][:transformer1] << l_field


	  .items[:data] << l_all

	  _local l_rope << rope.new()

	
	  _for a_key, a_value _over l_current_pl.keys_and_elements()
	  _loop
		  _local l_display_tree << display_tree.new(a_key, a_key.write_string, p_parent)
		
		  # l_display_tree.set_children_method(_self, :int!tree_list2|()|)
		  l_display_tree.set_children_method(_self, :int!details_tree2|()|, a_value)
		
		
		
		  l_rope.add(l_display_tree)
	  _endloop

	  >> l_rope
	
  _endmethod
  $


  _pragma(classify_level=basic, topic={icpp_integration_status})
  _method icpp_status_gui_plugin2.int!details_tree2(l_current_pl, _optional p_parent)
	  ## 
	  ## our first attempt at this
	  ## 

	  _local l_list << rope.new()


	
	  _for a_key, a_value _over l_current_pl.keys_and_elements()
	  _loop
		  _local l_display_tree << display_tree.new(a_key, a_key.write_string, p_parent)

		  _if  a_value.class_name _is :property_list
		  _then
			  l_display_tree.set_children_method(_self, :int!details_tree3|()|, a_value)
		  _endif
		
	
		  l_list.add(l_display_tree)
	  _endloop

	  >> l_list
  _endmethod
  $

  _pragma(classify_level=basic, topic={icpp_integration_status})
  _method icpp_status_gui_plugin2.int!details_tree3(l_current_pl, _optional p_parent)
	  ## 
	  ## our first attempt at this
	  ## 

	  _local l_list << rope.new()
	
	  _for a_key, a_value _over l_current_pl.keys_and_elements()
	  _loop
		
		  _local l_display_tree << display_tree.new(a_key, a_key.write_string, p_parent)
	
		  # l_display_tree.set_children_method(_self, :int!tree_list2|()|)
	
		  l_list.add(l_display_tree)
	  _endloop

	  >> l_list
  _endmethod
  $

#+end_src
** Several ways to structure the display_tree & styled_string 
*** Straightforwards  using simple vector
#+begin_src magik

  l_pl << { _false, "Petaling-Jaya", "123678456", "whatever what" }
		  
       

  # both p_parent passed in as argument from the method (Eg: int!details_tree(l_current_pl, _optional p_parent)). l_key from looping through the property_list l_current_pl
  l_display_tree << display_tree.new(l_key, l_pl, p_parent)


  # :properties_1 is a custom style
  l_display_tree.styled_string << {
					  :toggle, 1
					  :bold, :value, 2,
					  :properties_1, :value, 3,
					  :properties_2, :value, 4
				  }

  l_rope.add(l_display_tree)

#+end_src
** Using property_list
#+begin_src magik

  l_pl << property_list.new_with(:first, l_value[:desc1],
				:second, l_value[:desc2],
				:third, l_value[:desc3]
		       )
  l_display_tree << display_tree.new(l_key, l_pl, p_parent)

  l_display_tree.styled_string << {:image, :default, # just a style
				   :bold, :value, :first,
				   :properties_1, :value, :second,
				   :properties_2, :value, :third
				  }
  
#+end_src
* Common errors again:
** No defiitino for binary operator: symbol(<some_name>) cf integer(1) caused by something like 
#+begin_src magik

  "asd"[:some_name]

#+end_src
** which produces
[[./stuff_i_installed_at_work/common_error_10.png]]
* Weird shit, please write   this, while u still remember
#+begin_src magik


  ## the following code will fail, despite the else, not sure why
  ## instead define variables, and return that final
  ## variable outside conditional
  _method icpp_status_gui_plugin2.external_name2(l_coll_name)
	  _local l_string << ""
	  _if l_coll_name = "sub_substation"
	  _then
		  l_string << "Substation"
		  ## return at this point is weird, without the last >>, go try it and see
	  _else
		  l_string << "nothing"
	  _endif

	  >> l_string
  _endmethod
  $

#+end_src
* Task 19: 
** A single variables l_style_holder holding many custom defined text style and image scheme, to attacah to a single tree_item. So in theory, good management is having many styles inside a tree_item
** We encounter an error involving datastore not initialized, usually this means we did not open dataset connections without closing them (we also need to add protect blocks). But if we need to, we can solve it:
#+begin_src magik

  _block
	  gis_program_manager.cached_dataset(:swtnbgis).user.close()
  _endblock

#+end_src
* Task 22:
** we can get the full KV label, by combining cgis_label and voltage_map, (both from the cable installation object)
*** Eg: \\10.215.92.21\Smallworld\TNB_GIS\DIST\modules\functional_modules\cgis_custom_tool_modules\cgis_tnb_validation_checks\source\Conductor\data_validation_cond_with_invalid_child_phase_and_spec.magik
** We should read on how specification is  used to produce assets and phase. 
* Random education 
** [[https://redplanetsolutions.sharepoint.com/:v:/s/rpstrainingstuff/EdDwXymNTTRLlYNU3c4iX9wBO3asQZ9o2X2wsHBDiQT9-g?e=cPsjLa&nav=eyJyZWZlcnJhbEluZm8iOnsicmVmZXJyYWxBcHAiOiJTdHJlYW1XZWJBcHAiLCJyZWZlcnJhbFZpZXciOiJTaGFyZURpYWxvZy1MaW5rIiwicmVmZXJyYWxBcHBQbGF0Zm9ybSI6IldlYiIsInJlZmVycmFsTW9kZSI6InZpZXcifX0%3D][sharepoint RPS]]
*** Link only  viewable internally
*** ADMS data source is GIS only
*** ADMS needs data in the form of network model
*** ADMS & GIS help each other, separate systems
*** ADMS provides permanent network changes to GIS (example, a SS is faulty, and ADMS provides permanent changes to GIS, aka. a new SS is rerouted)
** GIS Adapter is a system of truth
** initial load EO --> ADMS
** The CIM is a model
** the GIS adapter profile is under <GIS Adapter>\eo_cim\modules\cim_profiles\eo_ge_dcim\resources\base\data, and has the extension .owl.
** the location of  this XML is read from cim_adapter_properties.xml
** 2 types of exchange job types
*** full circuit export
***  incremental export. (kinda like design changes export)
** Job types that can be created
*** CIM Circuit Initial Load - the initial load to target system
*** CIM circuit re-export
*** CIM Circuit Resync - after already loaded, similar to above. 2 steps required becoz CIM server is designed to be simple
*** CIM design as built - via a design state transition. An XML created after analyzing differences
*** CIM Design Republish - if above has failed
** 
* Task 25:
** Slightly  related, but cool none the less:
#+begin_src magik

  _block
	  ds << gis_program_manager.cached_dataset(:electric)
	  ds.go_to_alternative("|Working_Top|DM Top|parent_test|child_test")
	  ds.switch(:write)
	  ds.merge()
	  ds.commit()
  _endblock
  
#+end_src
** This actually worked, for easily editing our FME:
#+begin_src magik

  _block

	  system.putenv("SW2SHP_PROJ_DIR", "\\10.215.92.21\Smallworld\TNB_GIS\DIST\scripts\FME_data_migration")
	  system.putenv("Differential_export", "False")
	  system.putenv("FME_EXE_FILE", "C:\apps\FME\fme.exe")
	  system.putenv("MAP_DIR", "\\10.215.92.21\Smallworld\TNB_GIS\DIST\scripts\FME_data_migration\Mapping_files_full")
	  system.putenv("FME_EXE_FILE", "C:\apps\FME\fme.exe")
	  system.putenv("cs_SWORLDSWAF", "UTM84-47N")
	  system.putenv("server_SWORLDSWAF", "localhost")
	  system.putenv("port_SWORLDSWAF", "30002")
	  system.putenv("MAX_FEATURES", "10")
	  system.putenv("cs_shape", "LL-WGS84")
	  system.putenv("export_shapefile_path", "\\10.215.92.21\Smallworld\TNB_GIS\DIST\scripts\FME_data_migration\output\ardie")
	  system.putenv("FME_LOG", "\\10.215.92.21\Smallworld\TNB_GIS\DIST\scripts\FME_data_migration\fme_log_files\ardie")
	  system.putenv("pred_xml_path", "\\10.215.92.21\Smallworld\TNB_GIS\DIST\scripts\FME_data_migration\smallworld\XML_File\export_config_full.xml")

	  #system.putenv("FME_EXE_FILE", "C:\apps\FME\fme.exe")
	  #system.putenv("FME_EXE_FILE", "C:\apps\FME\fme.exe")
	  #system.putenv("FME_EXE_FILE", "C:\apps\FME\fme.exe")
	  #system.putenv("FME_EXE_FILE", "C:\apps\FME\fme.exe")

	  _local proj_dir << system.getenv("SW2SHP_PROJ_DIR")
	  #sw_module_manager.load_module(:tnb_mail_sender)

	  write(" Process Started.......")

	  _if system.getenv("Differential_export") = "True"
	  _then

		  load_file("".concatenation(proj_dir,"\smallworld\magik\diff_fix\fme_output_set.magik"))
	  _endif

	  load_file("".concatenation(proj_dir,"\smallworld\magik\diff_fix\fme_processor.magik"))
	  load_file("".concatenation(proj_dir,"\smallworld\magik\load_fme.magik"))
	  load_file("".concatenation(proj_dir,"\smallworld\magik\ARDIE_delta_filter_engine.magik"))
	  load_file("".concatenation(proj_dir,"\smallworld\magik\fme_differential_export_engine_new.magik"))	
	  load_file("".concatenation(proj_dir,"\smallworld\magik\cgis_pseudo.magik"))
	  load_file("".concatenation(proj_dir,"\smallworld\magik\ARDIE_process_fmw.magik"))

	
	  #load_file("".concatenation(proj_dir,"\smallworld\magik\checkpoint_clean.magik"))
	  #load_file("".concatenation(proj_dir,"\smallworld\magik\output_config.magik"))		
	  write(" Translation Completed.......")

  _endblock  


#+end_src
* How to access server 21 from 25 (probably the same LAN or something). Using the dollar sign ($) one can also access any volumn of disk
#+begin_quote

\\10.215.92.21\c$\Users

#+end_quote
* GUI notes from talk
** cool GUI notes from talk
*** "a" is the most interesting part we learned. An _unset row means the GUI will add rows indefinitely. Same with _unset column
[[./stuff_i_installed_at_work/gui_note_t/GUI_note_from_talk_1.png]]
*** "b" left :col_alignment is the only thing that matters for the label, pushing it neat against the left. :col_alignment for its parent container can left :fill
[[./stuff_i_installed_at_work/gui_note_t/GUI_note_from_talk_2.png]]
*** "c" the :col_alignment and the :col_spacing is the only thing we need for the buttons to arrange properly, spaced evenly, between each other and outer
[[./stuff_i_installed_at_work/gui_note_t/GUI_note_from_talk_3.png]]
*** "d" the 3 --> bottom_spacing, top_spacing, min_width --> is the only thing we need for the look of the button. min_width is recommened, in case text is super short, but we need consistent button size
[[./stuff_i_installed_at_work/gui_note_t/GUI_note_from_talk_4.png]]
*** Sample
[[./stuff_i_installed_at_work/gui_note_t/GUI_note_from_talk_Sample.png]]
* How to insert date format (SQL)
** Relevant to our oracle? we havent tried yet
*** https://stackoverflow.com/questions/7536628/how-to-insert-date-and-time-in-oracle
** Turns out  we  dont need it, coz in our we can just leave it as unset, and it will enter current date auto (refer to examples below, task 30)
* Task 30
** use .empty? instead of  .size, saves LOTS of  time
#+begin_src magik

  _if l_found.an_element().project.job_type = "CPP Projects" _andif _self.is_icpp?(l_active_name)
  _then
	  _self.project_name << l_active_name
	  l_find_status << {:found, l_found.an_element()}
  _endif

#+end_src
** The first parameter for activate_relative_to() is what determines whether it closes properly based on parent. We need to feed it the parents top_frame. (Apparently, the framework.new()  plays very little role)
#+begin_src magik




  _local l_fw,name,l_top_frame


  name << :detail_dialog

  _if (l_fw << _self.get_dialog(:detail_dialog)) _is _unset
  _then
	  l_fw << cgis_icpp_status_get_details_framework.new( :name, _self,
							      :resource_module_name, _self.module_name,
							      :config_definition_file_name, "details_config.xml",
							      :gui_definition_file_name, "details_gui.xml",
							      :title,"ERMS Integration Values")
	  _self.cache_dialog(:detail_dialog,l_fw)
  _endif

  l_fw.maximizable? << _false 
  l_fw.resizable?   << _false    



  l_fw.activate_relative_to( _self.framework.top_frame, _unset, _self.framework.top_frame, 500, 300)



  >> l_fw

#+end_src
** How to update SQL commands
#+begin_src magik

  _block
	l_ds << gis_program_manager.cached_dataset(:dude_eo)
	a_query << "update WBS_ICPP_PROJECTS
		set description = 'another test'
	       where id = 999
	       "
	a_stream << l_ds.user.sql_modify(a_query)
_endblock

#+end_src
** How to delete in SQL commands. (Dont over-rely in testing, can always use update, to trick our GUI)
#+begin_src magik

  _block
	  l_ds << gis_program_manager.cached_dataset(:dude_eo)
	  a_query << "delete from WBS_ICPP_PROJECTS where id = 1"

	  a_stream << l_ds.user.sql_select(a_query)

  _endblock

#+end_src
** How to select all. Note the .close() which is required to avoid running out of datastore cache. Unlike the 2 above.
#+begin_src magik


  _block
	  l_ds << gis_program_manager.cached_dataset(:dude_eo)
	  a_query << "select * from WBS_ICPP_PROJECTS"

	  a_stream << l_ds.user.sql_select(a_query)
	  a_stream.close()
  _endblock

  
#+end_src
** 
* Task 31
** SmallWorld Office Suite Administration --> Design Administration --> State Model --> New State Model
*** Insert name of new state model
*** Insert simple basic states. Example:
**** New Job --> In Design --> Design Approved -->  Pre Construction ---> In Construction --> As Built Changes --> Post Pending --> Posted
** SmallWorld Office Suite Administration --> Design Administration --> Project Types 
*** Its  only when we create a New Entry here do we get to see the  output of the following command  work
#+begin_src magik

  # Project  Type and State  Model   has the same name --> test1
  swg_dsn_admin_engine.state_model_for_job_type("test1")

#+end_src
* The code below works
#+begin_src magik

  



  _pragma(classify_level=basic, topic={jb_test})
  _method swg_dsn_scheme.my_transition_check()
	  ## 
	  ##

	  project_name << swg_dsn_admin_engine.active_scheme.project.name
	  args << swo_qm_state_model_transition_engine.args_for_qm_job(swg_dsn_admin_engine.active_scheme, "New Job", "In Design")
	  desc << " some description by random ardie"
	  swg_dsn_admin_engine.js_submit_job_request(
		  property_list.new_with(
			  :type,  :my_custom_job,
			  :name, project_name,
			  :description, desc
				),
		  args)

  _endmethod
  $



  _block


	  # for some strange reason, we cant replace proc  with a method
	  # and class of our own, we should try this again some time

	  sw_job_engine.define_job_type( :my_custom_job, 
					 _proc()
						 write("Hello World!")
						 a_stream << external_text_output_stream.new_appending("C:\Users\ahmadardie.r\Desktop\my_custom_log.csv")
						 a_stream.write("some data")

						 a_stream.close()	
					 _endproc, :|invoke()| )

	  my_server << sw_job_engine.new(_unset, _unset, _unset, :my_custom_server)
	  my_server.trace_level << 0
	  my_server.picker_type << :priority
	  my_server.start()

  _endblock

#+end_src
** just like above except using build in job type
#+begin_src magik

    _pragma(classify_level=basic, topic={jb_test})
  _method swg_dsn_scheme.my_custom_merge_and_post()
	  ## 
	  ##
	
	  project_name << swg_dsn_admin_engine.active_scheme.project.name
	  args << swo_qm_state_model_transition_engine.args_for_qm_job(swg_dsn_admin_engine.active_scheme, "As Built Changes", "Post Pending")
	  desc << " some meaningless desription"
	  swg_dsn_admin_engine.js_submit_job_request(
		  property_list.new_with(
			  :type,  :merge_and_post_scheme,
			  :name, project_name,
			  :description, desc
				),
		  args)
	
  _endmethod
  $


#+end_src
** 
* Task? (32-ish not really related)
** Flow so far
*** New Job --> In Digitization
**** Oracle is  updated automatically Hence cgis_sw_jobs will have its status changed automatically
**** ---
*** Much later
**** if our design LV migration is completed (record presented in LV_MIG_COMPLETED_STATION) moving our design to CPP Preparation will produce an error, where we dont have premission to access "\\10.215.129.92\WorkflowFiles\Drawings\CPP Projects\KUALA LUMPUR SELAT\design-name\Consultant_drawings\".  Folder of design doesnt exist  (consultant_drawings_1.png)
** How to create phase
#+begin_src magik

  swg_dsn_admin_engine.create_build_phase(Design_Record , Name of the Phase )

  _block
	  l_attrs << property_list.new()
	  l_area << swg_dsn_admin_engine.active_scheme.project.project_areas
	  l_attrs[:boundary] << l_area.an_element().area
	  l_scheme << swg_dsn_admin_engine.active_scheme
	
	  pp << swg_dsn_admin_engine.create_build_phase(l_scheme, l_scheme.name + "_01", l_attrs)
  _endblock  
#+end_src
** EDIT BELOW, write about eq_includes?() (Instead of some trick using using _orif  )
#+begin_src magik

  _if {"QAQC Validation","As Built Updates"}.eq_includes?(p_target_state_name)
	_then
		to_mail_ids << {"amillia.amran@tnb.com.my"}
	
		#Commented by Arun GK[26-01-2024] , [Ready for Posting, Posting
		# Approved & Posting Declined] states removed from CPP Projects
		#Ticket TC1-T934
		#{"Posting Approved","Posting Declined","Data Posted"}
	_elif {"Data Posted"}.eq_includes?(p_target_state_name)
	_then
		to_mail_ids << {"amillia.amran@tnb.com.my"}
	_endif
	#Ended by Arun GK

	tnb_mail_sender.send_mail_notification(to_mail_ids,to_subject,to_remarks)

#+end_src
** this lists all products, starting with layered prod, and then config products
** you can upgrade the database, go to GUI --> Configuration - Smallworld Core --> Datamodel Tools
** Create a new config file and save it (you have to select implementers)
** Run the upgrade note, save the new file somewhere (.ds) and point to it in gis_aliases using the following  variable
#+begin_src magik

SW_ACE_DB_DIR      = %SMALLWORLD_GIS%/../cambridge_db/ds/ds_admin

#+end_src
** Modules and  products
*** session --> product --> application --> modules
*** a product registers a product, based on documentation
*** so the product  below refers to folders, and putting a module inside automatically runs the module (an app acts like a top level module)
*** Note as well, "runalias" is a separate session from "Office Design"

#+begin_src magik




  magik_session.register_new(
	  "eo_closed",
	  :parent_session, "sw_common_office:common_office",
	  :add_products, { :sw_dm, :soms },
	  :optional_products, { :custom_products, :sw_core_lp, :sw_dm_lp, :soms_lp, :sw_common_office_lp, :sw_electric_office_lp},
	  :load_modules, { :sw_eo_image },
	  :startup_options, startup_options )


  magik_session.register_new(
	  "eo_open",
	  :parent_session, "eo_closed",
	  :startup_proc, :startup,
	  :soc_names, { :electric_dm, :design_config },
	  :load_modules, { :dtm_insert_transaction, :meal_menu_test, :editor_adds },
	  :startup_options, startup_options,
	  :open_database_proc, open_database_proc )

#+end_src
*** and of course, the "application module" is a folder AND a top leve module that provides other modules
*** the  product.def is a layered product
* Our System
** \\10.215.129.79\Smallworld\TNB_GIS\COMN\modules\tnbgis_common_code\source\basic_addtions
*** The file setvars_cst400 has the print(self) trick
* Task33
** For 2 days, havent dont anything. No progress so far.
** Readings on merge and post operations
*** Design manager in Electric Office
**** fully  supported
**** phases can only be created in designs that dont have subdesigns. Also, if it has phases, cant create subdesigns
**** Design Manager CAD tools
**** DLTs are compataible, but requires for creatins installations and assets
**** displayed designs --> showing changes in the map
*** Conflicts
**** conflict can happen at any level of hierarchy, of any dataset. Eg:  We have a subdesign, with data from 3 diff datasets, therefore, there  are  6  separate opportunties for conflist to  happen
*** Merge and post, as interactive or batch transaction job
**** To run the merge and post as a batch transaction job, set the swg_dsn_admin_engine shared constant interactive_conflicts? to false.
**** to run the merge interactively, but post as batch transaction job, only set  interactive_conflicts? is true
**** TO run both ia-ly, both set to true
*** Best practice is to set an interim  design state for the design integration
**** Eg: As Built --> Post Pending --> Posted
** In order to understand more on this topic, we should explore Data Modelling in the 4.9 core docs
** good code statements
#+begin_src magik

  swg_dsn_admin_engine.active_build_phase.has_been_posted_to_design_top?()

  # the transition is am object too
  swg_dsn_admin_engine.active_scheme.state_model.transition("New Job", "In Digitization")

  # get source or destination
  swg_dsn_admin_engine.active_scheme.state_model.transition("New Job", "In Digitization").source_state
  swg_dsn_admin_engine.active_scheme.state_model.transition("New Job", "In Digitization").dest_state

  # get attributes of a  state
  swg_dsn_admin_engine.active_scheme.state_model.transition("New Job", "In Digitization").target_state.state_attributes_string

#+end_src
* Task_KPI_2
** We need to rewrite this again later
** a_world << an_object.all_worlds.an_element()
** smallworld_product.applications.an_element().plugin(:maps).set_current_map_selection(an_object.geometry_set(a_world)) 
** What I did on 16-08-24
*** edited cim_adapter_properties.xml under eo_cim_configuration to attempt changing the mapping xml file it reads
* Task 34
** writing documentation on multiphase transitioning test case - scenarios
*** 
* more reading:
** STM exists becoz, the default is long transaction.  And the usual is 1 alternative per user. But STM allows the management of several users for 1 alternative.
** database priority, there's also drawing order and rendering geometry, which is different
* Task 35
** CIM
* Task 36
** How to get project_folder, coz I keep forgetting
#+begin_src magik

  swg_dsn_admin_engine.active_scheme.project.project_folder

#+end_src
** How is it set at the code level? is it custom? is it core?
* Common errors:
#+begin_src magik

  _try _with cond				
  (ok?, sch) << create_project_and_scheme(project_attributes, schema_attributes,area_sr)
  # ========== some stuff
  _if ok?
  _then
	  write("+++ Created Design in SW  - ",sch.name,%tab,"ID - ",sch.id)
	  ext_db_user.sql_modify("update cgis_sw_jobs set sw_id = ? where id = ?", sch.id, an_ext_db_rec.id)
	  ext_db_user.commit()					
  _endif				
  _when error
	  write("error while creating or updating design - ", an_ext_db_rec.job_name, " - ", cond.report_contents_string)
	  failed_designs.add(an_ext_db_rec.job_name)
  _endtry	

#+end_src
** example error traceback:
#+begin_src magik

  error while creating or updating design - D-MER-S21-0007 - Stale record handleerror while creating or updating design - D-MER-S21-0007 - Stale record handle

#+end_src
* Task 40
** How to call a mysql procedure inside SW. But what is a SQL procedure?
#+begin_src magik

  l_br_no << l_db.sql_procedure("UPDATE_SWITCH_BREAKER_NUMBER",{l_cgis_label,_unset})  

#+end_src
*** The procedure
#+begin_src sql

create or replace PROCEDURE UPDATE_SWITCH_BREAKER_NUMBER(
    p_area_code IN VARCHAR2,
    p_result OUT VARCHAR2
) IS
BEGIN
    -- Calling the function get_switch_breaker_number and assign the result to the OUT parameter
    p_result := GET_SWITCH_BREAKER_NUMBER(p_area_code);

    -- Commit the changes to ensure that updates are saved
    COMMIT;
END;


#+end_src
** Passing own method into run_engine(). Method is in its own class. Notice the add_dependent. (Still not sure why its necessary)
#+begin_src magik

  _self.add_dependent( _self )
  _self.run_engine( _thisthread.background_priority, :cgis_breaker_details|()| )

#+end_src
** Also write about this one  please. Useful way of organizing stuff. In theory, can do --> a_class.update_name_in_oracle(). And progressively combine several statements into a_class.update_somefields_in_oracle()
#+begin_src magik

  _pragma(classify_level=advanced,topic={job_area, oracle})
_method swg_dsn_scheme.update_job_area_in_oracle()
	## 
	## Update the job area in oracle once the design area is
	## updated in smallworld
	##

	_try _with cond
		ext_db << gis_program_manager.cached_dataset(:dude_eo)
		ext_db_user << ext_db.user				
		area << _self.oracle_area_geom()
		area << area.slice(3,area.size-1)
		sql_update_stmt << write_string("update dudeeo.cgis_sw_jobs set area=", area, " where job_name=?")
		ext_db_user.sql_modify(sql_update_stmt, _scatter {_self.name})
		ext_db.commit()
	_when error
		print(cond)
	_endtry	
_endmethod
$

#+end_src
* Construction View and far merging (aka. What is far merge)
** [[https://smallworld.gedigitalenergy.com/documentation/sw53/en/swDocs5.htm#../Subsystems/DesignManager/Content/Implementation/6ConstructView.htm?Highlight=far%20merge][We need to write about this one later, coz we are busy]]
* Never compromise self-learning
** Never compromise
#+begin_src magik

  # coordinate:(102.2681826,2.331683058) ??

  _block # ardieardie
	  _local all_cs << gis_program_manager.databases[:electric].user_visible_coordinate_systems
	  _local a_sel << smallworld_product.application(:tnb_sweo_dm_eo_dist_user).plugin(:maps).current_map.current_selection
	  _local cs1 << app.coordinate_system 
	  _local cs2 << gis_program_manager.databases[:electric].user_visible_coordinate_systems[:|Long-Lat WGS84 (degree)|]
	  _local tt << transform.new_converting_cs_to_cs(cs1, cs2)
	  my_sel << a_sel.transformed(tt)
  _endblock  
  
#+end_src
** Here we go
#+begin_src magik


  # listing all possible coordinates available (from dataset)
  gis_program_manager.databases[:electric].user_visible_coordinate_systems
  # creating a new one
  a_cs << gis_program_manager.databases[:electric].user_visible_coordinate_systems[:|Long-Lat WGS84 (degree)|]
  # setting the current coordinaate to a different one
  !current_coordinate_system!   << a_cs


  _block
	a_coord << coordinate.new(101.6550015,3.229047352)
	# a_field << gis_program_manager.databases[:electric].collections[:sub_substation].field(:location)
	# _for a_geom _over gis_program_manager.databases[:electric].geometry_within_radius(a_coord, 30, :point, a_field)
	# _loop
	# 	write(a_geom.rwo)
	# _endloop
	
	_for a_geom _over gis_program_manager.databases[:electric].geometry_within_radius(a_coord, 30)
	_loop
		write(a_geom.rwo)
	_endloop
_endblock 


#+end_src
* Stupid remote detail
** Theres no icpp integration tool for  tnb_gis_dist_user_non_sso_open_dev ??
* Management
#+begin_src magik

  # the url for  user space server is (Eg:)
  # \\10.215.92.21\c$

  # the url for SW app server is (Eg:)
  # \\10.215.129.79\

  # some env for gis_aliases have these features
  # SW_JOB_STM_SRV		= DISABLED #||10.215.92.15:3010
  # SW_DM_STM_SRV		= DISABLED #||10.215.92.15:3020
  # SW_SHORT_STM_SRV	= DISABLED # ||10.215.92.15:3030
  # SW_CIM_STM_SRV		= DISABLED # ||10.215.92.15:3040

#+end_src
* Notice the "change of state" in the code below
** from  //10.215.129.79/Smallworld/TNB_GIS/DIST/modules/functional_modules/cgis_custom_tool_modules/cgis_snc_customer_display_menu/source/
#+begin_src magik

  _method snc_customer_display_menu_gui_plugin.selected_records

	  _local l_colour_style << :red

	  _local l_str << styled_string.new(:value, :dsn_number,
					    :tab, :value, :pri_inst_id,
					    :tab, :value, :ca_number,
					    :tab, :value, :premise_id,
					    :tab, :value, :reg_struct_group,
					    :tab, :value, :installation_id,
					    :tab, :value, :prj_scm_name,
					    :tab, :value, :snc_notify_no,
					    :tab, :value, :coordinates,
					    :tab, :value, :con_obj_id)
	  _local l_styled_string << l_str

	  _local 	l_str_color << styled_string.new(l_colour_style,:value, :dsn_number,
						   :tab,l_colour_style,:value,:pri_inst_id,
						   :tab,l_colour_style,:value,:ca_number,
						   :tab,l_colour_style, :value, :premise_id,
						   :tab,l_colour_style, :value, :reg_struct_group,
						   :tab,l_colour_style, :value, :installation_id,
						   :tab,l_colour_style, :value, :prj_scm_name,
						   :tab,l_colour_style, :value, :snc_notify_no,
						   :tab,l_colour_style, :value, :coordinates,
						   :tab,l_colour_style, :value, :con_obj_id)


	  # ===== some code...
	  # ===== ...

	  l_styled_string << l_str


	  # ===== some code...
	  # ===== ...



	  _if dsn.status = "Completed" _orif dsn.status = "Posted"
	  _then
		  l_styled_string << l_str_color					
	  _endif


	  # ===== some code...
	  # ===== ...
	  _local pty << property_list.new_with(
				:dsn_number, an_el.perform(:device_serial_number),
				:pri_inst_id, an_el.perform(:primary_installation_id),

				:ca_number, an_el.perform(:contract_account_number),
				:premise_id, an_el.perform(:premise_id),
				:reg_struct_group, an_el.perform(:bcrm_reg_structure_group),
				:installation_id, an_el.perform(:meter_id),
				:prj_scm_name, psname,
				:snc_notify_no, an_el.perform(:snc_notification_number),
				:coordinates, an_el.perform(:customer_priority_code),
				:con_obj_id, an_el.perform(:cgis_tariff_code))


	  _local l_display_tree << display_tree.new(an_el, pty)
	  l_display_tree.styled_string << l_styled_string
	  l_list.add(l_display_tree)

	  >>  l_list

  _endmethod
  $

#+end_src
* iCPP/CPP workflow reminder
** When running the sync scheduler from As Built Updates, its EASY to forget many times. you need to set_status of actual SW scheme 1 step behind, otherwise you will NEVER get any phase creation. Meaning SW -> "CPP Preparation", Oracle for both main design and phase -> "As Built Updates"
* Read The Cambridge Database Layered Product
* Readings, experiments
** What is a Data Dictionary?
** Implementation of RWO fields (Case Datastore Objects), important as it  determines final size records and tables
*** physical fields become stored fields
*** logical fields --> derived fields
*** geometric fields --> methods
*** join fields --> methods
** Network Type maps geometry into a network
** EO data model object groupings
*** conducting equipment
*** TODO structure (look if theres such attriute in remote TNBSW)
*** circuit --> what conducting eq eventually becomes --> can be brokern into sectiosn --> for  better managemente
** Key concepts
*** lifecycle status
*** network type
*** phasing
*** assets
*** specifications --> assets are joined to a specification record
* Task51 (still same KPI)
** In order to connect to an example oof Sheath (diaelectri 20). One example shows:
*** 1 Hub  --> 2 Bays --> 1  Rack --> Slot no. 4 --> 1  Card --> 20  PORTS!!
** Gas Disributio
*** ArcGIS Pipeline Referencing 
* Thigs to read or  delete:
** https://desktop.arcgis.com/en/arcmap/latest/extensions/network-analyst/understanding-connectivity.htm
** Interesting point
*** Manifold in SW = Connectivity Group in ArrcGIS (maybe)
* Task55 trick
** To auto  align the columns in Excel, click the upper-left triangle in the corner of the cell area. And double click any border between headers
* My experiments Task55_z, downloaded Manifold viewer only
** https://manifold.net
* Task56
** Tested some business rules, becoz updating FL and EQ of Switch Bank and Fuse (eo_isolating_eqpt_inst) cannot be done manually, and updating the FL and EQ of the owning RMU will not affect it. 
** Expected behaviour, to ensure no duplicates of EQ and FL all over the place.
** Some cool code
* Task 57
** Looks like we reading about service_providers now
*** update_ermspm_asset_attrib_service_provider
**** update_ermspm_asset_attrib_service_provider.create_logger_file
**** update_ermspm_asset_attrib_service_provider.remove_logger_file
**** update_ermspm_asset_attrib_service_provider.|UpdateERMSPMAssetAttrib|()
**** update_ermspm_asset_attrib_service_provider.find_and_update_records_in_intg_coll()
**** update_ermspm_asset_attrib_service_provider.find_rmu_record_in_oracle()
**** 
*** Bifrost is the default and main configuration for GSS
** GSS base config can be inherented. Base configs are: (some of  these can be done locally for the app, no need for  service)
*** language name mappings
*** file sweep
*** 
** GSS paths are simply a way to organize service, and apply a config section to it  all. Example, all services under GSS path /admin have all those configs applied to it
** Example:
*** [[./stuff_i_installed_at_work/GSS/gss_config_full.png]]
*** appending to server_config_<component>.json. Example:  server_config_eo_web.json, server_config_solr.json & server_config_base.json.
*** Configuration for a SOAP service
**** the GSS path part (parent key of config), is how to externally request the service
** Keywords
*** GeoSpatial Server
*** Web services platform
*** database-independent GSS basic framework plugins
*** http_service_request_handler_plugin
*** database pool plugin
*** rabbitmq plugin
*** logger
*** map cache manager
** 
** TODO Search the files or words:
*** gss_basic_vertx_config.xml
*** <SCRIPTS_DIR>
*** <GSS_LOCAL_DIR>
*** file sweep
*** http_service_request_handler_plugin
*** map_cache_manager
*** rabbitmq
*** database_pool
*** rabbit_connection
*** map_options_provider
*** server_config_emaps.json
*** gis_aliases
**** gss:gss_closed
**** gss:gss_camdb_vertx_open 
*** opening a cambridge database treats it like a product. Search for cambridge_db in gis_aliases & register.magik
*** soap
*** <plugin name="outbound_http" class_name="http_outbound_plugin">
** small writings:
*** XML namespace and alias. (when you read, namespace is  just the URi)
*** In the example, the prefix becomes the alias, so its easy define attributes in elements later on
#+begin_src xml

  <!-- <prefix:myElement -->
  <!--     xmlns:prefix ="URI"> -->

  <!-- Example: -->
  <!-- <SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"> -->
  <!-- This declaration defines SOAP_ENV as an alias for the namespace: http://schemas.xmlsoap.org/soap/envelope/ -->

  <!-- Example: -->

  <SOAP-ENV:Envelope
      xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"
	  SOAP-ENV:encodingStyle=
	  "http://schemas.xmlsoap.org/soap/encoding/">
    <SOAP-ENV:Header>
      <HeaderA
	  xmlns="HeaderURI"
	  SOAP-ENV:mustUnderstand="0">

	The text of the header
	  </HeaderA>
    </SOAP-ENV:Header>
    <SOAP-ENV:Body>


    </SOAP-ENV:Body>
  </SOAP-ENV:Envelope


#+end_src
** Findings:
*** //10.215.92.15/Smallworld/TNB_GIS/DIST/modules/dist_gss_custom/modules/dist_gss_custom_application/resources/base/data/gss_basic_dist_config.xml
*** We  still DONT KNOW, how to call  service
*** //10.215.92.15/Smallworld/TNB_GIS/DIST/modules/application_modules/tnb_sweo_dm_eo_dist_user_application/resources/base/data/config.xml
** Write the following please,  just check SW doc under "Outbound HTTP plugin configuration", and check under config.xml under tnb_sweo_dm_eo_dist_user_application:
#+begin_src xml

  <plugin name="outbound_http" class_name="http_outbound_plugin">

  <properties>

  <external_endpoints>

    <endpoints>

  </external_endpoints>

</plugin>



#+end_src
** The outbound http plugin must be configured for an app to consume REST or SOAP services
*** 
* Which is which
** 21 is CR
** 15 is MnS
** 11 is staging
* Task 60. Important points to remember:
** When checking tracebacks, check the whole traceback for "error"
** quit design properly, quit app and session one-by-one. If done correctly you will be asked to "log out"
* Task 61.  (Operational Area script)
** even though, I quickly solved the script very quickly, I misunderstood instructions again
** Users wanted to know if any of the Operational Areas had invalid values. Despite the instruction emphasizing no. of invalid values in record. Users will eventually manually edit records. Which mans ID of records are VERY IMPORTANT
** 
