* Day 1:
** [[https://makefiletutorial.com/#makeflags][makefiletutorial]]
** 3 things: targets, preq, commands
** targets can also be files
** preq appear generally in the middle, (optically). Example
#+begin_src makefile-gmake

  blah: blah.o
          cc blah.o -o blah # blah.o appears middle, (optics)

  blah.o: blah.c
          cc -c blah.c -o blah.o # # blah.c appears middle, (optics)

  # Typically blah.c would already exist, but I want to limit any additional required files
  blah.c:
          echo "int main() { return 0; }" > blah.c # runs if file doesnt exist

#+end_src
** [[https://makefiletutorial.com/#variables-pt-2][makefiletutorial variables]]
** symbols like := act like parenthesis scoping, in that it stops the assignment from going up to the parent
#+begin_src makefile-gmake


  one = one ${later_variable}

  two := two ${later_variable}
  # ===== it looks similar to this:
  # (two := two ${later_variable})


  later_variable = later

  all:
          echo $(one)
          echo $(two)

#+end_src
* Day 2:
** https://earthly.dev/blog/make-flags/
** flags
*** flags can be placeholders for options in commands
*** Eg: ls -lhrt, so a flag might be $mylist for -lhrt
*** However, make defines standard, such as CFLAGS or CXXFLAGS
*** why? actually, it doesnt matter. But with standard naming, you can use implicit rules
*** "implicit rules" = you dont have to list commands, for common operations, like compiling file.c to file.o
*** remember our recursive variable definition? By recursive definition, we can have a flag with both "default required" and "user additions"
#+begin_src makefile-gmake

CFLAGS = -g # Optional. Not required for proper compilation
ALL_CFLAGS = -I. $(CFLAGS) # -I. is required for proper compilation
main.o: main.c
        $(CC) -c $(ALL_CFLAGS) main.c

#+end_src
** $(CFLAGS)
*** the required option passed to compiler
** $(CXXFLAGS)
*** same but for C++ compilers
** $(CPPFLAGS)
*** its for the preprocessor, its a separate exe from compiler, but the compiler calls it, so we pass this to the compiler
** $(LDFLAGS)
*** -L
*** like preprocessor but for linker, the compiler calls it, we pass directory path containing the libraries
** $(LDLIBS)
*** -l
*** space separated libraries
* Day 3:
** installed tree-sitter
** cloned emacs 29 from savannah
#+begin_quote

git clone https://git.savannah.gnu.org/git/emacs.git -b emacs-29

#+end_quote
* Day 4:
** Successfully compiled Emacs 29 in ~/my-emacs-29, the few installed stuff below
#+begin_quote

./configure --with-tree-sitter --with-json  --with-native-compilation=aot --with-mailutils --with-pop --prefix=/home/ardie/my-emacs-29
sudo apt install gcc-10
sudo apt install libgccjit0 libgccjit-10-dev
sudo apt-get install libjansson4 libjansson-dev

#+end_quote
* Day 5:
** Successfully installed treesitter, but have yet to fully utilize it, dont understand combobulate at all
** created treesit-language-source-alist, and ran M-x treesit-install-language-grammar
* Day 6:
** Successfully installed combobulate by using this [[https://github.com/mickeynp/combobulate?tab=readme-ov-file][link]] (and make sure "path-to-git-checkout-of-combobulate" is pointing our checkedout combobulate repo)
* Day 7:
** Successfully added hydra mode using combobulates 
* Day 8:
** eCreated an image copying script correctly with directory creation for my Org-mode Obsidian tablet
* Day 9:
** we improved our Emacs hydra mode to use both ***-sexp and ***-word functions
* Day 10:
** I instaled Rust using this link: [[https://www.digitalocean.com/community/tutorials/install-rust-on-ubuntu-linux][digitalocean]]
* Day 11:
** Fixed the radio to include values Yes and No, now it works to trigger subgroup elements (ID that starts with subgroup::)
* Day 12:
** managed to successfully install LSP from [[https://www.reddit.com/r/emacs/comments/ejc1az/lspmode_select_python_interpreter_virtual/][reddit link]]. Using eglot and LSP works automatically by default. Just point the variable. But since Virtual Environments are the "parents" of both of these, we need to setup insude use-package pyvenv
#+begin_src lisp

(setenv "WORKON_HOME" "/home/ardie/python-emacs-workspace/project_delete_1/myenv")
  
#+end_src
** Which required:
#+begin_src shell

  pip install 'python-language-server[all]'

#+end_src
** we learnt a little Rust Bevy. Our understanding of events and sprites, and having played with PyGame, seems to help slightly. We needed to install some libraries in order for bevy to work
#+begin_src shell

  sudo apt-get update; sudo apt-get install --no-install-recommends libasound2-dev libudev-dev libwayland-dev libxkbcommon-dev

#+end_src
* Day 13:
** we learnt to draw boxes for our foldable stool
** I think we figured out a way to make foldable stools thanks to our plan
* Day 14:
** we did our fiverr finally,
** Write this somewhere
*** [[https://www.pythontutorial.net/tkinter/tkinter-photoimage/][OOP way to make PhotoImage always available, and never mysteriously dissapear]]
*** [[https://python-forum.io/thread-43494.html][read this please]]
** tkinter by design is single threaded, reduced complexity, but also makes it awkward, we need a button to basically to refresh view of edited image
#+begin_src python

  Vimage = wandImage(filename=r"./temp/current.jpg")
  Vimage.resize(mainLabelWindowX,mainLabelWindowY)
  blob = Vimage.make_blob(format="jpg")
  VmainImage = ImageTk.PhotoImage(data=blob)

  tkinter.Button(window, text='View', command=updateImageLabel).pack()

  # ===== we define function before that like this
  # ===== NOTE: example should include try catch to show possible errors

  def updateImageLabel():
    global VmainImage
    Vlabel.configure(image=VmainImage)


#+end_src
** As a best practice, we always put declare when passing the PhotoImage, based on the OOP link above
* Day 15:
** Fiverr madsstudio: we struggled with the error of "VlabelImage has no attribute .config()", thinking it was "global" keyword. turns out .grid should be in a separate line, becoz we wont be getting the correctn object/variable type. We found the error online, LUCKY us, we have to be very careful. Solution? Dont know, maybe always datatype?
#+begin_src python

  def VupdateImageLabel():
    global VlabelImage

    VmainImage = # some stuff obviously
    ImageTk.PhotoImage(Vimage)
    VlabelImage.config(image=VmainImage)


  VlabelImage = tkinter.Label() # some options obviously
  VlabelImage.grid() # some options obviously

  # ===== never do this
  # VlabelImage = tkinter.Label().grid()




#+end_src
* Day 16:
** we discovered several documentation alternatives in python. Using the inspect module
* Day 17:
** we had some progress on little the Python Fiverr Lightroom alternative. Now effect hides better
* Day 18:
** I downloaded Scriabin Etude, the "beautiful octave" piece. Using this [[https://github.com/LibreScore/dl-librescore][link]]. I used Tampermonkey, very hacky
* Day 19:
** I filed the half nut. I mortised an angle.  
** Getting mentally ready for teaching Hanifa cycling
* Day 20:
** The quick release vise project completely failed. Never forget the goal, to save money, and defeat corporate monopoly
** Created template of very cool eLisp (mouse-8) shortcut, using combobulate and treesitter. No fail so far, but not sure how to build others upon this
* Day 21:
** We added some batch operations, it was simple but our brain is spaghetti, so we became super slow
** We added eLisp that saves buffer, and auto-runs shell-command before a special mouse click
* Day 22:
** We added the -color-matrix (IM) for the tinting. Seems overkill, but if felt like it had potential. It seems playing with raw IM commands is much more fun and interesting (such as swapping colors, red and blue)
** Our code has no awareness of key events, becoz aparently pg.event.get() only work once. 
* Day 23:
** We read 
* Day 24:
** created a very cool Emacs workflow, that uses moues buttons
** the workflow script is branch-aware and commit-aware.
** mouse button 9 clicked => if branch is working, and commit is work and fuzz, commit is amended
** mouse button 9 clicked => if branch is working and commit is NOT work and fuzz, it creates a clean empty work and fuzz
** mouse button 9 clicked => if branch is fuzz, it points to the latest working changes (using detached switch)
** mouse button 10 clicked => runs project
** combined with worktree, and branch-commit-aware functions, these is no longer any need, for stashing, squashing, etc
* Day 25:
** we managed simple text integer filtering of our practice CPP code, success
* Day 26:
** We managed a simple Qmake and make .pro file
** so far still no Qt GUI example
* Day 27:
** Installing with the following makes Qt includes work in c++:
#+begin_quote

sudo apt install qt5-default qtbase5-examples qtbase5-doc-html

#+end_quote
* Day 28:
** fixed the Emacs neovim killer workflow, still using (compile) command, but interactive now. So now it works for user prompt input as well
** added a kill-buffer hydra, neovim killer
* Day 29:
** managed a very simple Qtwindow and Qtlabel
** learnt how to supress warning using qmake (no need makefile), with QMAKE_CXXFLAGS += -Wno-unused-variable
** getting a sense of what is, /initializing a base class constructor/, so I understand this error
#+begin_quote

hello.cpp:59:47: error: no matching function for call to ‘QVBoxLayout::QVBoxLayout(QWidget&)’

#+end_quote
** it simply means im passing the wrong argument, so below is ths fix:
#+begin_src c++


  // instead of this
  QWidget window;

  // should be this
  QWidget *window = new QWidget();

  

#+end_src
** Now window is pointer, /*window instead of window, we use this now:
#+begin_src c++

  // instead of this
  pointOneLongLabel.setFrameStyle(QFrame::Panel | QFrame::Sunken);
  pointOneLongLabel.setText("first line\nsecond line");
  pointOneLongLabel.setAlignment(Qt::AlignBottom | Qt::AlignRight);

  // should be this
  pointOneLongLabel->setFrameStyle(QFrame::Panel | QFrame::Sunken);
  pointOneLongLabel->setText("first line\nsecond line");
  pointOneLongLabel->setAlignment(Qt::AlignBottom | Qt::AlignRight);


#+end_src
** 
* Day 30:
** sudo apt install qtcreator qt6-base-dev 
* Day 31:
** Created a very simple 2 label, 1 text, 1 button
** We can use either lambda inside entry point
#+begin_src c++

  int main(int argc, char *argv[]){
    // --- snip ---
    QObject::connect(ui.pushButton, &QPushButton::clicked, [&]() {
      ui.textEdit->append("Text inserted by button.\n"); // Appends text to a new line
      // Or textEdit->insertPlainText("Text inserted by button."); for plain text
    });
    // --- snip ---
  }

#+end_src
** We can also do the same above inside class constructor, reminder, QObject is parent of all, hence no "imports" needed
** We can also create do the on_.._clicked, and even combine to provide 2 actions, but why would we?
#+begin_src c++



  void MainWindow::on_pushButton_clicked()
  {
    // Accessing a QLabel named 'myLabel'
    ui->label->setText("Button clicked!");
    ui->textEdit->append("Text inserted by button.\n"); // Appends text to a new line
  
      newbox = new NewBox(this);
      newbox->show();
  }

#+end_src
** Remember to include the includes in the header files (pun intended)
** The entry point:
#+begin_src c++


  #include <QApplication>
  #include "mainwindow.h" // Assuming your MainWindow class is defined in mainwindow.h

  int main(int argc, char *argv[])
  {
    QApplication a(argc, argv); // Create the application object
    MainWindow w;               // Create an instance of your MainWindow class
    w.show();                   // Display the main window
    return a.exec();            // Start the application's event loop
  }


#+end_src
* Day 32:
**   // In summary: You should call show() on the instance of your MainWindow class, not on the Ui::MainWindow object. The Ui::MainWindow object is responsible for setting up the visual components within your MainWindow.
** It means its wrong name inside the Ui namespace:
#+begin_quote

mainwindow.cpp: In constructor ‘MainWindow::MainWindow(QWidget*)’:
mainwindow.cpp:7:16: error: ‘justAnotherBox’ in namespace ‘Ui’ does not name a type

#+end_quote
** We finally understand \*cpp \*ui \*h can be a different name. we can call it special_box.h special_box.cpp, then special_-_box.ui. 
*** Our Qt qmake will create ui_special_-_box.h
*** we decided to rename our parent widget different
*** When we use Qt designer, we open a .ui as mainwindow, widget, etc.... -> that is the parent widget (QMainWindow, QWidget) with a name
*** The only "connecting dot" required is the class name
#+begin_src nxml
  <?xml version="1.0" encoding="UTF-8"?>
  <ui version="4.0">
    <class>NewBox</class>
    <!-- ... -->
   <connections/>
  </ui>
#+end_src
*** the rest to remember:
**** member initializer list for a constructor -- !make sure to remember to write the correct widget!
**** constructor body is optional, but we can put stuff. We can put out our Ui from the .Ui file, we can also change stuff of the members we defined in the list (above)
#+begin_src c++



  MyWidget::MyWidget(QWidget *parent)
    : QWidget(parent), // Initialize the base class QWidget
      m_button("Click Me!", this), // Initialize m_button
      m_label("Hello, Qt!", this)  // Initialize m_label
  {
    // Constructor body (optional, for additional setup)
    m_label.setGeometry(10, 10, 100, 30);
    m_button.setGeometry(10, 50, 100, 30);
  }



  NewBox::NewBox(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::NewBox)
  {
    ui->setupUi(this);
  }
#+end_src

***** 
* Day 33:
** Header files serve to make as "appends" to the main .cpp
** Although, its implied, apparently we STILL need to manually #include <...>
** This implies compilers unawareness of names
** This adds confusion -> itsnt better to just make includes implied and the compiler do that work?
** Another confusion is that includes dont act like namespaces, includes often have different names, we discovered we can do this:
*** a file called specialbox.h --> so we do this --> #include "specialbox.h"
*** the class inside called NewBox --> so we do this -->   newbox = new NewBox(this);
** So maybe just use the same name
** We also need to this inside our mainwindow.h
#+begin_src c++

  class MainWindow : public QMainWindow
  {
    // --- snip ---
  private:
    Ui::MainWindow *ui;
    QLabel *myLabel;
    QWidget *newbox; // --- becoz includes is what makes the .cpp code "aware" of the classes/objects
  };
#+end_src
** Otherwise we get this error, which can be difficult to catch:
#+begin_quote

mainwindow.cpp:40:3: error: ‘newbox’ was not declared in this scope; did you mean ‘NewBox’?

#+end_quote
* Day 34:
** We need to test these:
*** headers
#+begin_src c++
  


  #include <QCoreApplication>
  #include <QSqlDatabase>
  #include <QSqlQuery>
  #include <QSqlError>
  #include <QDebug>
#+end_src
*** connection
#+begin_src c++

  int main(int argc, char *argv[])
  {
    QCoreApplication a(argc, argv);

    QSqlDatabase db = QSqlDatabase::addDatabase("QPSQL");
    db.setHostName("localhost"); // or your PostgreSQL server IP
    db.setPort(5432); // Default PostgreSQL port
    db.setDatabaseName("your_database_name");
    db.setUserName("your_username");
    db.setPassword("your_password");

    if (!db.open()) {
      qDebug() << "Error: Failed to connect to database:" << db.lastError().text();
      return 1;
    } else {
      qDebug() << "Connected to database!";
    }

    // ... perform database operations ...

    db.close(); // Close the connection when no longer needed

    return a.exec();
  }

#+end_src
*** queries
#+begin_src c++

  QSqlQuery query;

  // Example: Inserting data
  if (query.exec("INSERT INTO users (name, email) VALUES ('John Doe', 'john.doe@example.com')")) {
    qDebug() << "Data inserted successfully.";
   } else {
    qDebug() << "Error inserting data:" << query.lastError().text();
   }

  // Example: Selecting data
  if (query.exec("SELECT id, name, email FROM users")) {
    while (query.next()) {
      int id = query.value(0).toInt();
      QString name = query.value(1).toString();
      QString email = query.value(2).toString();
      qDebug() << "ID:" << id << "Name:" << name << "Email:" << email;
    }
   } else {
    qDebug() << "Error selecting data:" << query.lastError().text();
   }
#+end_src
*** .pro
#+begin_quote

QT += core sql

#+end_quote
*** [[https://doc.qt.io/qtforpython-6/tutorials/basictutorial/tablewidget.html][Py related example for filling table]]
*** we really need to learn focus shit
*** https://www.google.com/search?client=ubuntu&channel=fs&q=c%2B%2B+qt+textbox+focus+selected
* Day 35:
** Comon error, caused by forgetting to put it in qmake .pro file
#+begin_quote

hello.cpp:27:10: fatal error: QSqlDatabase: No such file or directory

#+end_quote
* Day 36:
** We spent so much time listening to AI about installing postgresql drivers, but instead its as simple as this (from askubuntu.com)
#+begin_quote


sudo apt install libqt5sql5-psql

#+end_quote
** If we listened to AI, we would have created stupid Makefiles, inside Qt plugins directory (this is usually inside Qt installation directory)
* Day 37:
** We spent so much on time on learning the db.setHostName() function, only to discover the url was wrong, dpg-d288ja49c44c73a6oi5g-a.singapore-postgres.render.com
* Day 38:
** We discovered package-check-signature is the way to solve the -> Can't check signature: No public key
** We discovered a trick using 
* Day 39:
** "Code is data!!"
** So turns out alist, is an example of "code is data", alist entries are treated as literal data, so functions will and variables will not work
** Here is an example, we used to solve our alist (which will be used in our Windows Emacs)
#+begin_src emacs-lisp


  (setq backup-directory-alist `(("." . ,(concat ardie/all-compute-cfg-dir "emacs_backup_files"))))
  
  ;; instead of this
  (setq backup-directory-alist '(("." . "/home/ardie/my-emacs-29-config/emacs_backup_files")))


#+end_src
** The backquote (also known as quasiquote) stops evaluation of list, which allows the comma to force evaluation of sub-expressions inside.
* Day 40:
** Reminder, this error is usually compiler having trouble finding that declaration, maybe header files naming the wrong variables:
#+begin_quote

table.cpp:13:12: error: ‘mData’ was not declared in this scope

#+end_quote
* Day 41:
** We spent so much time trying to change header data in different ways.
** First we thought of ways to use QList or something for the header "stream".   QStringList is apparently a string stream (whatever??). POINTLESS
#+begin_src c++

      mainHeader << "Column 1" << "Column 2" << "Column 3"; // Example headers

#+end_src
** We then spent so much time on setHeaderData, several points
#+begin_src c++


  // ===== void will not work
  void TableModel::setHeaderData(int section, Qt::Orientation orientation, const QVariant& value, int role)
  {
    // ===== example from https://forum.qt.io/topic/157414/how-to-implement-setheaderdata-in-a-subclass-of-qabstracttablemodel
    // ===== has no assignment of value (QVariant) itself
    headerDataChanged(orientation, section, section);  // emit signal!

  }
#+end_src
** Whats the purpose of const override? we have no clue, probably more OOP excessiveness
#+begin_src c++

  // table.h 
  // whats this for??
    QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const override;

#+end_src
** when it comes bool return types in func declaration, we can do a simple:
#+begin_src c++


  if(// calling the setHeaderData())
  qDebug() << "unable to set header";

#+end_src
** without   <int, QVariant> below;
#+begin_src c++

  QHash<int, QVariant> m_horizontalHeaderData;

  // without which, we get this error READ (??) --> class template argument deduction
  // table.h:31:3: error: invalid use of template-name ‘QHash’ without an argument list
  // table.h:31:3: note: class template argument deduction is only available with ‘-std=c++17’ or ‘-std=gnu++17’
  // ===== apparently solution: CONFIG += c++17 in .pro, we havent tried

#+end_src
** so turns out setHeaderData internally calls headerData, which explains why we need to set both:
#+begin_src c++



  QVariant TableModel::headerData(int section, Qt::Orientation orientation, int role) const
  {
    if (role == Qt::DisplayRole) {
      if (orientation == Qt::Horizontal) {
        // return mainHeader.at(section); ----- the original does nothing, simply copy existing
        return m_horizontalHeaderData[section];
      } else {
        return section + 1; // Row numbers
      }
    }
    return QVariant();
  }

  bool TableModel::setHeaderData(int section, Qt::Orientation orientation, const QVariant& value, int role)
  {
    m_horizontalHeaderData[section] = value;
    headerDataChanged(orientation, section, section);  // emit signal!
    return true;
  }
#+end_src
* Day 42:
** We attempted llama.cpp from the [[https://github.com/ggml-org/llama.cpp][ggml link]], and according to some ggml is what makes it runnable on non-dedicated-GPU laptops.
** It uses some concept called "inference", to infer what your hardware is running on
** this needed cmake installed to run llama-cli, so thats what we installed
* Day 43:
** our attempt at using qmodelinde led to a stupid rabbithole, although we did learn a lot
** we test our code awareness, we could NOT get a specific item using qmodelindex.
** everytime we tried we got a segmentation fault error.
** Inside MainWindow::on_pushButton_clicked(), created again:
#+begin_src c++

  TableModel *tablemodel = new TableModel(this);


  QModelIndex var1 = tablemodel->index(0,0);

      qDebug() << "Data at var1:" << tablemodel->data(var1, Qt::DecorationRole).toString();


#+end_src
** the "implemented" data() ☝️ always produced error, becoz our tablemodel is out of bounds
*** our table.h used this constructor as a member variable
  // explicit TableModel(QObject *parent = nullptr);
*** it should look something like this, more or less
#+begin_src c++

  // pointer or reference to the QAbstractTableModel
  explicit MyWidget(QAbstractTableModel* model, QWidget* parent = nullptr);
  ~MyWidget();

  // and our "implementation" of constructor should look like this
  // note it needs "awareness" of our parents
  MyWidget::MyWidget(QAbstractTableModel* model, QWidget* parent)
    : QWidget(parent), m_tableModel(model) // Initialize m_tableModel
      
#+end_src
** we learn how a Qlist looks like
(("Data A1", "Data B1", "Data C1"), ("Data A2", "Data B2", "Data C2"), ("Data A3", "Data B3", "Data C3"))
** but becoz of our scope "awareness" problem as above, this produced an error
#+begin_src c++

  return mainData[index.row()][index.column()];
  // but qDebug() works at looking at it.
  qDebug() << mainData;

#+end_src
* Day 44:
** we need to learn various ways on passing a pointer to the model, as, argument to constructor

#+begin_src c++

  // MyWidget.h
  #include <QWidget>
  #include <QAbstractTableModel>

  class MyWidget : public QWidget
  {
    Q_OBJECT

  public:
    explicit MyWidget(QAbstractTableModel* model, QWidget* parent = nullptr);
    ~MyWidget();

  private:
    QAbstractTableModel* m_tableModel; // Pointer to the shared model
  };

#+end_src
** using that argument passed in member initializer list
#+begin_src c++

    // MyWidget.cpp
  #include "MyWidget.h"
  #include <QTableView> // Example usage

  MyWidget::MyWidget(QAbstractTableModel* model, QWidget* parent)
      : QWidget(parent), m_tableModel(model) // Initialize m_tableModel
  {
      // Now you can access m_tableModel within the constructor
      // For example, setting it to a QTableView
      QTableView* tableView = new QTableView(this);
      tableView->setModel(m_tableModel);

      // ... further constructor logic using m_tableModel
  }

  MyWidget::~MyWidget()
  {
      // No need to delete m_tableModel here if it's owned elsewhere
  }
  
#+end_src
** Create the model and pass it to your constructor
#+begin_src c++

      // main.cpp or another class
    #include <QApplication>
    #include <QStandardItemModel> // Example model
    #include "MyWidget.h"

    int main(int argc, char *argv[])
    {
        QApplication a(argc, argv);

        // Create the model (e.g., QStandardItemModel)
        QStandardItemModel* myModel = new QStandardItemModel(10, 3); // 10 rows, 3 columns

        // Pass the model to the constructor of MyWidget
        MyWidget myWidget(myModel);
        myWidget.show();

        return a.exec();
    }

#+end_src
** This example of declaring member variable pointer and "initialize" it inside a mamber initializer list. It might be different. BUT WE NEED TO READ:
#+begin_src c++

  #include <iostream>

  // A simple class to be pointed to
  class Data
  {
  public:
    int value;
    Data(int val) : value(val)
    {
      std::cout << "Data object created with value: " << value << std::endl;
    }
    ~Data()
    {
      std::cout << "Data object destroyed with value: " << value << std::endl;
    }
  };

  class MyClass
  {
  private:
    Data *dataPtr; // Declare a pointer member variable
  public:
    // Constructor using a member initializer list to initialize the pointer
    MyClass(int initialValue) : dataPtr(new Data(initialValue))
    {
      std::cout << "MyClass object created." << std::endl;
    }

    // Destructor to deallocate the dynamically allocated memory
    ~MyClass()
    {
      delete dataPtr; // Deallocate the memory pointed to by dataPtr
      dataPtr = nullptr; // Set the pointer to nullptr to avoid dangling pointers
      std::cout << "MyClass object destroyed." << std::endl;
    }

    void printData() const
    {
      if (dataPtr)
        {
          std::cout << "Value pointed to by dataPtr: " << dataPtr->value << std::endl;
        }
      else
        {
          std::cout << "dataPtr is null." << std::endl;
        }
    }
  };

  int main()
  {
    MyClass obj(100); // Create an object of MyClass, which in turn creates a Data object
    obj.printData(); // Access and print the data through the pointer

    // When obj goes out of scope, its destructor will be called,
    // which then calls the destructor of the Data object pointed to by dataPtr.
    return 0;
  }

#+end_src
* Day 45:
** We are learning signals and slots, it seems sophisticated and better. But we forgot C++ is stupid, we need a template function for the compiler to resolve overloads.
** Stupid C++ 
** Notice the QOverload which is a template function (cant remember the compile error). We need the ::of, in older C++
#+begin_src c++

  connect(ui->comboBox_ssync, QOverload<const QString &>::of(&QComboBox::currentIndexChanged), this,  [&]() {
    qDebug() << "whaataat";
   });

#+end_src
* Day 46:
** We kept reinstalling Hugo becoz our 1s post never got views (locally)
** The error looks like something like this:
#+begin_quote

function "css" not defined

#+end_quote
** This is becoz the css function was introduced in Hugo 0.128+. And most popular themes seem to be updated along with it anway
** Our Hugo .deb (amd64) was never successful, becoz it required a some common features required extended_hugo, and that requires a newer GCC
** How it works: packaged Hugo uses latest GCC. 
** Only option -> install from source
** So we also installed Go (installed under /usr/local/go) -> installed HUGO (default: installed inside ~/go)
*** If any at any point, we installed the wrong hugo (Eg: instead of extended_hugo), we just remove ~/go. 
#+begin_quote

CGO_ENABLED=1 go install -tags extended github.com/gohugoio/hugo@latest

#+end_quote
* Day 47:
** Note the example below, which always confuses us. We are already getting better at C++, and yet this still confuses us.
** Note this is the recommended declaration of QString and QStringListModel inside a parent class definition
#+begin_src c++

  // ===== inside mainwindow.h
  QStringListModel *a_model;
  QStringListModel *model2;
  QString textInput_model;



  // ===== inside mainwindow.cpp
  model2 = new QStringListModel(this);
  QStringList list2;
  list2 << "Hanifa" << "Bev" << "Ardie";
  model2->setStringList(list2);

  ui->comboBox_ssync->setModel(model2); 

  ui->textEdit_ssync->setText(textInput_model);

#+end_src
** We keep getting perplexed by whether or not to put * in the parent definition
** Lesson 1:
*** In official docs, the constructor shows passing of parent
#+begin_src c++

  QStringListModel::QStringListModel(QObject *parent = nullptr)

#+end_src
*** QString:
#+begin_src c++


  QString::QString()

#+end_src
*** 
** Lesson 2 (ChatGPT):
*** Using a pointer
(QStringListModel *model)
**** is recommended because most Qt widgets and models are designed to work with the parent-child memory management system.
**** otherwise we have to manage lifetime ourselves
*** Why QString is different?
**** QString is not a QObject.
**** It does not participate in Qt’s parent-child memory management system.
**** It is lightweight and uses implicit sharing / copy-on-write under the hood, which makes it efficient to copy and pass by value.
** Lesson 3:
*** The QStringListModel definition (header) looks "eerily similar" to QMainWindow child definition
#+begin_src c++

  // ===== inside header definition
  MyWindow(QWidget *parent = nullptr);

  // ===== inside header definition
    MyWindow::MyWindow(QWidget *parent) : QMainWindow(parent)
    {    
    }
#+end_src
*** But we only deal with "implementations" with QMainWindow so far
*** But we pass the parent in QStringListModel in the example above. Reminder:
#+begin_src c++

  model2 = new QStringListModel(this);
  // ===== Other non-related example:
  QStringListModel *model = new QStringListModel(parentWidget); 

#+end_src
* Day 48:
** C++ function argument definitions, either the asterisk * and the ampersand &
*** Pointeres:
#+begin_src c++

  void modifyValueByPointer(int* ptr) {
    ,*ptr = 100; // Modifies the value at the address pointed to by ptr
  }

  int main() {
    int x = 10;
    modifyValueByPointer(&x); // Pass the address of x
    // x is now 100
    return 0;
  }

#+end_src
*** References:
#+begin_src c++

  void modifyValueByReference(int& ref) {
    ref = 200; // Modifies the original variable referred to by ref
}

int main() {
    int y = 20;
    modifyValueByReference(y); // Pass y by reference
    // y is now 200
    return 0;
}

#+end_src
*** Both are same-y
*** Pointer (*) is about control. It allows null. A common practice is this
#+begin_src c++
  time_t time (time_t *result);
#+end_src
*** the *result hints the user that passing null is allowed, if not current time is used.
*** In normal practice (outside function):
#+begin_src c++

  ,*var1 = 100;
  // means dereferencing (get deep value)
  &var1 = 100;
  // means getting address
  var1 = 100;
  // means assigning to pointer itself

  
#+end_src
*** And then
#+begin_src c++

  some_function(&regular_variable);
  // means passing the pointer by reference, regardless of source

#+end_src
*** "regardless of source", becoz the pointer doesnt care. It can be a local variable on the stack, or a register mapped into RAM
*** Yes, thats right. It can be a RAM!!
*** [[https://hackaday.com/2018/04/04/the-basics-and-pitfalls-of-pointers-in-c/][hackadays pointer in C]]
*** This is inline with the Strange Loop Conference presentation --> A programming system has 2 parts. The programming 'environment' is the part thats installed on the computer. The programming 'language' is the part that's installed in the programmer's head 
*** Extreme childish example: if each variable represented each motor, then its extreme control of motor on the language level.
* Day 49:
** We finally tried psycopg2 in a move away from sqlalchemy
* Day 50:
** We managed to do raw postgresql, we learnt about query parameters (as a way to avoid sql injection)
** We used 2 blogs, neon.com and 
* Day 51:
** Exploratory tip, there are is no "restart" for databases such as PostgreSQL:
** Which means control at that operation is often required in the "real world". 
** This is a great tip when learning stuff in the future
** Obviously, this is no indicator of good design
** So we have 
*** DROP SCHEMA public CASCADE;
*** CREATE SCHEMA public;
*** GRANT ALL ON SCHEMA public TO postgres;
*** GRANT ALL ON SCHEMA public TO public; -- Or to specific roles/users
** this means databases are not set (public) permissions by default. Probably, becoz of security freaks
* Day 52:
** Stupid childish dopamine hit, seeing the button works. what
* Day 53:
** New Admin Window
** I was correct, that programming requires a lot of personal space and freedom
** Who says pride is a sin? (Vaush)
** As usual C++ being stupid, it has no awareness of, array size, index position and also a new file you added in the language itself. 
** AKA, adding #include statements are not enough, the Makefile (in our case: .pro file for qmake) needs "awareness of the new file"
* Day 54:
** Lessons learnt, there is, the .ccls-cache files are in fact for IDE, and are safe to .gitignore
** While "undefined reference", we usually imagine to be imports related (header files), for constructors OurClass::OurClass(QWidget*) they in fact refer to Makefile issues. Again, C++ has "awareness" issues
* Day 55:
** We explored several stuff:
** For simple endpoints, (Chatgpt has several good examples). We explored:
** await 
#+begin_src javascript

  await fetch();

  await response.text(); // for this one, we could do JSON.parse, but it depends on whether the reponse object has JSONs

#+end_src
** express.js, its just a fast to setup a stupid server, LOL. Why is chatgpt helping me too much?
#+begin_src javascript

  const express = require('express');
  // ...

#+end_src
** https module to do the same thing, which we havent explored
#+begin_src javascript

  const https = require('https');

#+end_src
** eLisp, we managed to explore url-retrieve-synchronously, and it worked for the simple JSON example!!
#+begin_src emacs-lisp

  (let
    (
     ;; (url-request-extra-headers '(("Content-Type" . "application/json")))
     ;; ("Cookie" . "token_v2=testtest tets")     
     ;; (url-request-data (json-encode '(("requests" . ((("id" . "some-ID") ("table" . "block")))))))
     ;; "Authorization": "Bearer " + token,
     (url-request-extra-headers '(
				  ("Content-Type" . "application/json")
				  ("Accept" . "application/json")
				  ;; ("Authorization" . "Bearer some-notion-token")
				  ))
     )
     (progn
          (setq buffer (url-retrieve-synchronously "https://api.notion.com"))
          (setq buffer (url-retrieve-synchronously "https://jsonplaceholder.typicode.com/posts/1"))
          ;; (with-current-buffer buffer
	  ;;   (goto-char (point-min))
	  ;;   (re-search-forward "^$")
	  ;;   (delete-region (point) (point-min))
	  ;;   (buffer-string)
	  ;;   )
	  (switch-to-buffer
	   buffer
	   )
  ))

#+end_src
** Unfortunately, it still didnt work for notion, which is our MAIN GOAL
** We should read this again? Maybe that'll help
#+begin_src javascript

  import { Client } from '@notionhq/client';

// Initialize the Notion client
const notion = new Client({ auth: <notion-token> });

// Replace with the actual UUID of your Notion block
// const blockId_childPage = some block ID';
const blockId_paragraph = 'some ID';

async function getBlockContent(blockId_paragraph) {
  try {
    const response = await notion.blocks.retrieve({
      block_id: blockId_paragraph,
    });

    console.log('Block content:', response);
    console.log('type:', response.type);
  
    // To access the specific value, you'll need to inspect the 'response' object
    // based on the 'type' of the block.
    if (response.type === 'paragraph') {
      console.log('Paragraph text:', response.paragraph.rich_text[0].plain_text);
    }
      else if (response.type === 'heading_1') {
      console.log('Heading 1 text:', response.heading_1.rich_text[0].plain_text);
    } 

    // Add more conditions for other block types (e.g., 'to_do', 'bulleted_list_item') 
    // as needed, inspecting the 'response' object to find the relevant property.

  } catch (error) {
    console.error('Error retrieving block:', error);
  }
}

getBlockContent(blockId_paragraph);


#+end_src
** We fonud this cool link too: [[https://developers.notion.com/reference/intro][its got cool working curl example for a Notion database]]
* Day 56:
** setters and getters are a disease, although according to C++, if its public scoped, we can just
#+begin_src c++

  obj.publicMember = 10;

#+end_src
** we added a button to connect database and enable isUsersTableFilled, so we can view table
#+begin_src c++

  void MainWindow::on_buttonTableExists_clicked (){
    QVariant result = _openDatabase();
    isUsersTableFilled = true;
  }

#+end_src
** We NEED to redesign, so that the first button is a popup before opening window to either restart DB or not
** "Selected Indexes" are not entirely straightforward. They are protected behind, QItemSelectionModel (QTableView::selectionModel()) and QModelIndexList (from QItemSelectionModel::selectedIndexes())
** So the "model"and not the widget stores the selection
** Advantage? You can select several data to delete from DB.
** Again C++ has no awareness of index positions, so we use QModelIndexList::at(0)
#+begin_src c++

    QItemSelectionModel* selectionModel = ui->userTableView->selectionModel();

    QModelIndexList indexes = selectionModel->selectedIndexes();
    if (indexes.size()){
      QModelIndex index = indexes.at(0);
      qDebug() << index.row();
    }

#+end_src
