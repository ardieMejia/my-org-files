* Now that we understand the nastiness of OOP, we can finally read [[https://doc.qt.io/archives/qt-5.15/designer-using-a-ui-file.html][this]]. We REALLY need to transition smoothly from QT designer to Emacs workflow
* \*Pointers are a nightmare:
** C++ function argument definitions, either the asterisk * and the ampersand &
*** Pointeres:
#+begin_src c++

  void modifyValueByPointer(int* ptr) {
    ,*ptr = 100; // Modifies the value at the address pointed to by ptr
  }

  int main() {
    int x = 10;
    modifyValueByPointer(&x); // Pass the address of x
    // x is now 100
    return 0;
  }

#+end_src
*** References:
#+begin_src c++

  void modifyValueByReference(int& ref) {
    ref = 200; // Modifies the original variable referred to by ref
}

int main() {
    int y = 20;
    modifyValueByReference(y); // Pass y by reference
    // y is now 200
    return 0;
}

#+end_src
*** Both are same-y
*** Pointer (*) is about control. It allows null. A common practice is this
#+begin_src c++
  time_t time (time_t *result);
#+end_src
*** the *result hints the user that passing null is allowed, if not current time is used.
*** In normal practice (outside function):
#+begin_src c++

  ,*var1 = 100;
  // means dereferencing (get deep value)
  &var1 = 100;
  // means getting address
  var1 = 100;
  // means assigning to pointer itself

  
#+end_src
*** And then
#+begin_src c++

  some_function(&regular_variable);
  // means passing the pointer by reference, regardless of source

#+end_src
*** "regardless of source", becoz the pointer doesnt care. It can be a local variable on the stack, or a register mapped into RAM
*** Yes, thats right. It can be a RAM!!
*** [[https://hackaday.com/2018/04/04/the-basics-and-pitfalls-of-pointers-in-c/][hackadays pointer in C]]
*** This is inline with the Strange Loop Conference presentation --> A programming system has 2 parts. The programming 'environment' is the part thats installed on the computer. The programming 'language' is the part that's installed in the programmer's head 
*** Extreme childish example: if each variable represented each motor, then its extreme control of motor on the language level.
** But the REAL problem:
*** I've determined over the years that the main problem with pointers isn't the concept, it's the syntax. The * position being optional is one barrier to clarity, the second is the declaration which is opposite of a pointer's usage (you don't use the * if you are re-assigning the address of the pointer ptr_to_x = &y;). Then there's pointer arithmetic which overloads the + and -. Sadly it's way too late to clean it all up now, but in my opinion most people are bewildered because the syntax just isn't predictable. -- "Russell Beattie from Void Pointer in C demystified"
* Basics:
** An asterisk /* placed before a variable means the variable is a pointer.
** Example:
#+begin_src c++

  int* myPointer; // Declares myPointer as a pointer to an integer
  QString* namePtr; // Declares namePtr as a pointer to a QString object

#+end_src
** Ampersand & is "address of"
#+begin_src emacs-lisp

  int value = 10;
  int* ptr = &value; // ptr stores the address of 'value'
  ,*ptr = 20;         // Dereferences ptr and changes the value at that address to 20.
  // Now, 'value' is also 20.

#+end_src
** Notice how 3 lines magically mean "2 variables mean the same thing"
** How to instantiate a base class constructor, aka, its important to understand semicolons locations (coz that will be very confusing)
#+begin_src c++

  class Base {
  public:
    Base() {
      // Default base constructor
    }
  };

  class Derived : public Base {
  public:
    Derived() {
      // Base::Base() is implicitly called here before this body executes
    }
  };

#+end_src
* Errors learnt
** Compiler error, getting a sense of what is, /initializing a base class constructor/, so I understand this error
#+begin_quote

hello.cpp:59:47: error: no matching function for call to ‘QVBoxLayout::QVBoxLayout(QWidget&)’

#+end_quote
** It simply means wrong argument type passed, so we should pass pointer type to a QWidget object
* Introduction:
** Tools:
*** [[https://earthly.dev/blog/autoconf/][Components of Autotools]]  (probably very Linux centric way of making makefiles)
**** Flow?
***** these 3 tools:
****** --autoconf--
****** --automake--
****** --aclocal--
***** Generate (huge files):
****** "configure"
****** "Makefile.in"
***** Those 2 files are huge, so we only create these 2 files, which the tools use to create 2 HUGE files:
****** "configure.ac"
****** "Makefile.am"                      # ---------- the way to remember it is that both have .a* as extension
**** Demo:
***** Interestingly, their demo "Hello World" shows a different argument style unlike [[https://www.cyberciti.biz/faq/howto-compile-and-run-c-cplusplus-code-in-linux/][this site]]. Syntax:
#include <stdio.h>

int
main(int argc, char* argv[])
{
  printf("Hello World\n");
  return 0;
}
***** Here arguments can be left as (void)
**** autoconf:
***** Interesting to note, is that most options is abbreviate (autoconf to AC, automake to AM). Its also named with capital letters. Which is not my comfort zone.
***** Put exactly like this, in configure.ac:
AC_INIT([helloworld], [0.1], [maintainer@example.com])     # ---------- app name, version, who's maintainer
AM_INIT_AUTOMAKE                                           # ---------- automake is USUALLY used alongside automake, but not necessary, so mention this
AC_PROG_CC                                                 # ---------- look for a CC compiler (note how this is not a variable, maybe its called a primary)
AC_CONFIG_FILES([Makefile])                                # ---------- this autoconf should look for Makefile.in
AC_OUTPUT                                                  # ---------- output final "configure" script
**** automake:
***** Put like this, in Makefile.am
 AUTOMAKE_OPTIONS = foreign                                 # ----------
 bin_PROGRAMS = helloworld                                  # ---------- name of compiled binary (final program)
 helloworld_SOURCES = main.c                                # ---------- required input to compile
**** Finally!! compile:
aclocal                                                    # ---------- run this first
autoconf
automake --add-missing                                     # ---------- -add-missing necessary files, becoz program actually more thans Makefile.am
*** [[https://opensource.com/article/19/7/introduction-gnu-autotools][Similar but different]]
**** Similar but seems more confusing, defines primary "wrongly"?
**** autoconf:
***** same same
**** automake:
***** Example of not building a cPlusPlus project (interpreted languages such Bash, Perl, Python).
bin_SCRIPTS = bin/penguin                                  # ---------- SCRIPT is another primary
*****
*** [[https://devmanual.gentoo.org/general-concepts/autotools/index.html][This is site is Gentoo, YUCK. However, cool source of information, since I already understand Bash functions and such]]
**** [[./resources/cPlusPlus/automakeDiagram.png][Basic overview of major autotool components]]
**** autoconf:
AC_PREREQ(2.5)                                              # ---------- apparently, site claims this needed coz autoconf is not compatible between versions
AM_INIT_AUTOMAKE(1.8)                                       # ---------- site claims automake not compatible between versions, good habit to do both I guess
AC_PROG_CC                                                  # ---------- this is the only thing similar
AC_PROG_INSTALL
AC_PROG_LN_S
AC_PROG_RANLIB
.......... optional ..........
AC_CHECK_PROGS(regex_cmd, sed) if(){...}fi                  # ---------- checks the existance of non-standard apps like 'sed' for example
AC_C_CONST                                                  # ---------- check for compiler features -> can our compiler do const
.......... library and header checks ..........
AC_HEADER_STDC
AC_HEADER_DIRENT
AC_CHECK_HEADERS([stdlib.h stdio.h libintl.h locale.h])
AC_CHECK_LIB(ssl, SSL_free)
.......... and several others ..........

*** [[https://makefiletutorial.com/][Simple Makefile example, with tasty examples]]
**** We may need to move this, coz this one is not autotool-specific
*** Common mistakes:
**** always forgetting to update the name of primary/variable (I guess this is why its not accurate to call someAppName_SOURCES, etc, etc variables)
 bin_PROGRAMS = someAppName
 someAppName_SOURCES = src/someAppName.cpp
*** Some custom directories and stuff. Finally understood
**** https://stackoverflow.com/questions/20230827/how-to-set-include-paths-with-autotools
***** The only 1 line required is this in Makefile.am
AM_CPPFLAGS = -I$(top_srcdir)/other $(FAKELIB_CPPFLAGS)
***** But some examples put this in configure.ac (or even more):
FAKELIB_CPPFLAGS="-I${FAKELIB_DIR}/other"
**** https://stackoverflow.com/questions/3538705/adding-a-custom-installation-directory-option-to-autoconf-generated-configure-sc
***** Tried this with /doc directory. Works but of course, the only 'installing' is copying a README.md to a defined directory (/doc)
***** --- probably triggers an 'argument replacement' in configure. By inserting in configure.ac:
AC_SUBST([docdir], [$docdir])
***** --- once triggered can put inside Makefile.am ---
docdir = @docdir@
doc_DATA = README.md
*** A decently good official example.
**** https://www.gnu.org/software/automake/manual/html_node/index.html#SEC_Contents
*** [[https://cmake.org/cmake/help/latest/guide/tutorial/A%20Basic%20Starting%20Point.html][My first tutorial on CMake]]
**** A seemingly trivial but important difference between CMake and Autotool => is that Autotools is case-sensitive (mostly its special variables)
**** But CMake is NOT case-sensitive
***** Simple run (both works):
cmake .            # ---------- this produces CMakes own intermediary files (Makefile2, Makefile.cmake progress.marks etc..etc...)
cmake --build .    # ---------- this produces the Makefile and final .executable in 1 step
***** or
mkdir build; cd build
cmake ../.
cmake --build .    # ---------- cmake is apparently "blind" which makes it good
**** .h.in
***** separate #define (constants) usually inside .h file
****** why is #define inside .h.in ?
****** Demo_VERSION_MAJOR deduced automatically from CMakeLists.txt
****** not very useful for me (maybe for long-term bigger projects use)
**** Step 2: Adding a library:
***** Is it only in CMake(?):
****** function name is irrelevant!
****** CMake makes it easy, functions like these ----->:
******* add_executable(Demo demo.cpp) & target_link_libraries(Demo PUBLIC library)
******* and add_library(library mysqrt.cpp) in library-level CMakeLists.txt
****** -----> glues the names together. So for one library, .h file & /directory name & .cpp can be all different or the same name (/library & library.h & otherName.cpp)
** Tips
*** [[https://softwareengineering.stackexchange.com/questions/379202/folder-structure-for-a-c-project][Project structure]]
**** Write something
** Tutorials:
*** https://cplusplus.happycodings.com
**** Very useful site for refreshing if youre like me, and have not touched C/C++ in a long long time:
***** === writing something ===
*** https://riptutorial.com/c/example/3250/calling-a-function-from-another-c-file
**** Simple example of calling a function from another C file
**** Basically a header file, but primitive example
*** [[https://www.geeksforgeeks.org/map-associative-containers-the-c-standard-template-library-stl/][Professional looking site youre subscribed to]]
**** Write one you seriously read about this
*** Specific cases:
**** https://stackoverflow.com/questions/5838711/stdcin-input-with-spaces
***** How to force cin to take spaces (spaces are probably always a problem due to computing history)
std::string s;
std::getline(std::cin >> std::ws, s);
** Common errors:
*** error: ‘someFunction’ was not declared in this scope
**** Check function names in 3 places (Grrrrrr). main.cpp, someFunction.cpp & someFunction.h
**** this is usually scoping issue, which means the function name doesnt exist in space.
***** Reasons ==> wrong naming in the 3 places, (cout produces same error if no -> using namespace std;)
** Alternative Libraries:
*** 3D Game Engine
**** [[https://wiki.ogre3d.org/Ogre+Wiki+Tutorial+Framework][if we starting Ogre seriously, we rewrite this]]
***** Wewrite maybe not, coz were not using Ogre
* This is so cool:
** https://www.linuxjournal.com/content/getting-started-ncurses
*** this is about the ncurses library
*** has a cool triangle pattern challenge, probably applicable to Python as well
*** has a cool trick of generating random numbers from Eg: 1 to 10 (instead of random.randint(1,10)):
**** yi = getrandom_int() % maxlines; # ---------- modulus as a range cutter
* Makefile awesome writing, but maybe the tool itself is not awesome
** [[https://web.mit.edu/gnu/doc/html/make_14.html][mit makefile doc]] : rather useless, in its weird jumbled writing style. Informative, if only reference or experience. Almost written as an afterthought.
** [[https://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/][colby cs]] : slightly better, but specific. Calls variables "macro", target "rule", hence not great for beginners. Include s ways to make Makefile (haha), more generic. 
* QT nonsense:
** we learnt that you have Q--widget, Q--model, and Q--view
** [[https://www.bogotobogo.com/Qt/Qt5_QListView_QStringListModel_ModelView_MVC.php][cool trick]]
** [[https://felgo.com/doc/apps-howto-model-view-separation/][felgo separation of concerns example]]
** [[https://medium.com/e-fever/revised-qml-application-architecture-guide-with-flux-a1de143fe13e][revised QML application arch with Flux]]
** [[https://www.freecodecamp.org/news/an-introduction-to-the-flux-architectural-pattern-674ea74775c9/][flux unidirectional data flow]]
** [[https://woboq.com/blog/new-signals-slots-syntax-in-qt5.html][a Qt5 blog]]
** [[https://samdutton.wordpress.com/2008/10/03/debugging-signals-and-slots-in-qt/][sam dutton Debugging signals and slots]], wait this ones kinda stupid, becoz we found a better blog on signals and slots
** https://riptutorial.com/qt/example/17048/connecting-overloaded-signals-slots
** [[https://wiki.qt.io/Qt_for_Beginners][unusually great for beginners OFFICIAL documentation]]
** [[https://qt.developpez.com/doc/4.3/qstandarditemmodel/][A BETTER link less-abstracted docs on QStandardItemModel and others]]
* Qt better resources:
** [[https://ftp.nmr.mgh.harvard.edu/pub/dist/freesurfer/tutorial_packages_centos6/centos6/freesurfer-fsl-matlab-Linux-centos6_x86_64-dev/freesurfer/lib/qt/qt_doc/html/modelview.html][harvard tutorials]]
* MACROS are semi-bad, semi-dangerous but powerful
** [[https://www.reddit.com/r/C_Programming/comments/k37n57/how_to_properly_use_macros_in_c/][The shadowing problem]]
*** Wshadow is worth gold. 
*** It seems like the C way is to pick a unique identifier yourself -- e.g. prefixed with the macro's name. 
** For performance alternative, use better modern alternative inline functions
** 
* Namespaces (we achieved some epiphany, we realized the purpose of Ui as a namespace in Qt, is to avoid Qt Designer made stuff from clashing with purely-code classes)
** [[https://stackoverflow.com/questions/6955023/c-namespace-best-practice-dilemma][namespace some tricks]]
*** its considered bad practice to put using statements inside header files. But this guy does it anyway, as a way to avoid fully qualified names
** https://www.geeksforgeeks.org/cpp/namespace-in-c/
** https://learn.microsoft.com/en-us/cpp/cpp/namespaces-cpp?view=msvc-170
** https://www.learncpp.com/cpp-tutorial/naming-collisions-and-an-introduction-to-namespaces
** https://forum.qt.io/topic/27278/what-is-the-purpose-of-the-ui-namespace-in-qt
** https://doc.qt.io/qt-6/qt.html
* Mature tips:
** [[https://agiledeveloper.com/articles/cloning072002.htm][why copying objects is a bad idea]], this link also mentioned OCP by Bertrand Meyer
** [[https://hackernoon.com/the-open-closed-principle-c3dc45419784][Open-Closed Principle (OCP) by Bertrand Meyer]]
* Reading is always fun:
** [[https://www.syncfusion.com/succinctly-free-ebooks/cplusplus/pointers-references-and-const-correctness][pointers, references, const]], which also mentions RAII
** [[https://cburch.com/books/cptr/][c pointers]]
